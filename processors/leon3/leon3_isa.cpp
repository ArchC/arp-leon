/**
 * \file leon3_isa.cpp
 * 
 * \author Rogerio Alves Cardoso
 * 
 * \brief  The ArchC SPARC-V8/LEON3 functional model.
 * 
 * Behavior implementation file template.             
 * This file is automatically generated by ArchC      
 * WITHOUT WARRANTY OF ANY KIND, either express       
 * or implied.                                        
 * For more information on ArchC, please visit:       
 * http://www.archc.org                               
 *                                                    
 * The ArchC Team                                     
 * Computer Systems Laboratory (LSC)                  
 * IC-UNICAMP                                         
 * http://www.lsc.ic.unicamp.br   
 * 
 * \attention 
 * Copyright (C) 2002-2015 --- The ArchC Team
 *
 * This library is free software; you can redistribute    
 * it and/or modify it under the terms of the GNU         
 * Lesser General Public                                  
 * License as published by the Free Software Foundation; 
 * either version 2.1 of the License, or (at your option) 
 * any later version.                                     
 *															
 * This library is distributed in the hope that it        
 * will be useful, but WITHOUT ANY WARRANTY; 				
 * without even the implied warranty of				
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  	
 * See the GNU Lesser General Public License for 			
 * more details.
 * 	                    
 ******************************************************/
 

#include  "leon3_isa.H"
#include  "leon3_isa_init.cpp"
#include  "leon3_bhv_macros.H"
#include  "leon3_cpu_helper.H"

//!'using namespace' statement to allow access to all leon3-specific datatypes
using namespace leon3_parms;

//!Global Variables
static int processors_started  = 0; //!number of processors started
bool error_mode                = 0; //!error mode flag
bool halt_mode                 = 0; //!halt mode flag
static bool pb_block_ldst_byte = 0; //!load store byte lock
static bool pb_block_ldst_word = 0; //!load store word lock

//!Behavior executed before simulation begins.
void ac_behavior( begin ){
  REGS[0] = 0;     //writeReg can't initialize register 0
  npc = ac_pc + 4; //set NPC

  //FIXME: Put all configurations in a bootstrap file and load that in the PROM
  PSR.write(0xf30010e7);   //PSR initial value
  ASR[17] = 0x00000307; //LEON3 Configuration Register
  WIM.write(0x2);          // Invalidate the Window 1 {*restore before save} 

  //Stack pointer for multi-core platforms 
  writeReg(14, (AC_RAM_END + RAM_START_ADDR) - 1024 - processors_started++ * DEFAULT_STACK_SIZE);
  //%sp must always point to a free 64 bytes block, so %fp points to next block
  writeReg(30, readReg(14) + 0x68);
};

//!Behavior executed after simulation ends.
void ac_behavior( end ){};

//!Generic instruction behavior method.
void ac_behavior( instruction ){
  //processor enters in error mode
  if (error_mode)
  {
     stop(EXIT_FAILURE);
  }
};
 
//! Instruction Format behavior methods.
void ac_behavior( Type_F1 ){}
void ac_behavior( Type_F2A ){}
void ac_behavior( Type_F2B ){}
void ac_behavior( Type_F3A ){}
void ac_behavior( Type_F3B ){}
void ac_behavior( Type_FTA ){}
void ac_behavior( Type_FTB ){}
 
//!Instruction call behavior method.
void ac_behavior( call ){

  uint32_t addr = ac_pc + (disp30 << 2);
  writeReg(15, ac_pc); //!save pc into %o7(r15)
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("call 0x%x\n", addr);
  #endif
  ac_pc = npc;
  npc   = addr;

}

//!Instruction nop behavior method.
void ac_behavior( nop ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("nop\n");
  #endif
  ac_pc = npc;
  npc   = npc + 4;
}

//!Instruction sethi behavior method.
void ac_behavior( sethi ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("sethi %%hi(0x%x), %s\n", (imm22 << 10), reg_alias[rd]);
  #endif
  writeReg(rd, (imm22 << 10) & 0xfffffc00);

  ac_pc = npc;
  npc   = npc + 4;
}

//!Instruction ba behavior method.
void ac_behavior( ba ){
  uint32_t addr = (disp22 << 10) >> 8;
  addr += ac_pc;
  ac_pc = npc;
  npc   = addr;
  if (an)
  {
    ac_pc = npc;
    npc = npc + 4;  //!delay slot annuled
  }
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("ba%s 0x%x\n",an_s[an], ac_pc.read());
  #endif
}

//!Instruction bn behavior method.
void ac_behavior( bn ){
  ac_pc = npc;
  npc = npc + 4;
  if (an)
  {
    ac_pc = npc;
    npc = npc + 4; //!npc + 8 
  }
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("bn%s 0x%x\n",an_s[an], ac_pc.read());
  #endif
}

//!Instruction bne behavior method.
void ac_behavior( bne ){
  uint32_t addr = (disp22 << 10) >> 8;
  addr += ac_pc;
  ac_pc = npc;

  if (PSRicc_Z == 0) 
  {
	 npc = addr;
  } else {
    npc = npc + 4;
    if(an){
      ac_pc = npc;
      npc = npc + 4; //!Delay slot annuled
    }
  }
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("bne%s 0x%x\n",an_s[an], ac_pc.read());
  #endif
}

//!Instruction be behavior method.
void ac_behavior( be ){
  uint32_t addr = (disp22 << 10) >> 8;
  addr += ac_pc;
  ac_pc = npc;

  if (PSRicc_Z == 1) 
  {
	 npc = addr;
  } else {
    npc = npc + 4;
    if(an){
      ac_pc = npc;
      npc = npc + 4; //!Delay slot annuled
    }
  }
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("be%s 0x%x\n",an_s[an], ac_pc.read());
  #endif
}

//!Instruction bg behavior method.
void ac_behavior( bg ){
  uint32_t addr = (disp22 << 10) >> 8;
  addr += ac_pc;
  ac_pc = npc;

  if ((PSRicc_Z || (PSRicc_N ^ PSRicc_V)) == 0) 
  {
	 npc = addr;
  } else {
    npc = npc + 4;
    if(an){
      ac_pc = npc;
      npc = npc + 4; //!Delay slot annuled
    }
  }
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("bg%s 0x%x\n",an_s[an], ac_pc.read());
  #endif
}

//!Instruction ble behavior method.
void ac_behavior( ble ){
  uint32_t addr = (disp22 << 10) >> 8;
  addr += ac_pc;
  ac_pc = npc;

  if ((PSRicc_Z || (PSRicc_N ^ PSRicc_V)) == 1) 
  {
	 npc = addr;
  } else {
    npc = npc + 4;
    if(an){
      ac_pc = npc;
      npc = npc + 4; //!Delay slot annuled
    }
  }
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("ble%s 0x%x\n",an_s[an], ac_pc.read());
  #endif
}

//!Instruction bge behavior method.
void ac_behavior( bge ){
  uint32_t addr = (disp22 << 10) >> 8;
  addr += ac_pc;
  ac_pc = npc;

  if ((PSRicc_N ^ PSRicc_V) == 0) 
  {
	 npc = addr;
  } else {
    npc = npc + 4;
    if(an){
      ac_pc = npc;
      npc = npc + 4; //!Delay slot annuled
    }
  }
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("bge%s 0x%x\n",an_s[an], ac_pc.read());
  #endif
}

//!Instruction bl behavior method.
void ac_behavior( bl ){
  uint32_t addr = (disp22 << 10) >> 8;
  addr += ac_pc;
  ac_pc = npc;

  if ((PSRicc_N ^ PSRicc_V) == 1) 
  {
	 npc = addr;
  } else {
    npc = npc + 4;
    if(an){
      ac_pc = npc;
      npc = npc + 4; //!Delay slot annuled
    }
  }
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("bl%s 0x%x\n",an_s[an], ac_pc.read());
  #endif
}

//!Instruction bgu behavior method.
void ac_behavior( bgu ){
  uint32_t addr = (disp22 << 10) >> 8;
  addr += ac_pc;
  ac_pc = npc;

  if ((PSRicc_C || PSRicc_Z) == 0) 
  {
	 npc = addr;
  } else {
    npc = npc + 4;
    if(an)
	 {
      ac_pc = npc;
      npc = npc + 4; //!Delay slot annuled
    }
  }
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("bgu%s 0x%x\n",an_s[an], ac_pc.read());
  #endif
}

//!Instruction bleu behavior method.
void ac_behavior( bleu ){
  uint32_t addr = (disp22 << 10) >> 8;
  addr += ac_pc;
  ac_pc = npc;

  if ((PSRicc_C || PSRicc_Z) == 1) 
  {
	 npc = addr;
  } else {
    npc = npc + 4;
    if(an){
      ac_pc = npc;
      npc = npc + 4; //!Delay slot annuled
    }
  }
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("bleu%s 0x%x\n",an_s[an], ac_pc.read());
  #endif
}

//!Instruction bcc behavior method.
void ac_behavior( bcc ){
  uint32_t addr = (disp22 << 10) >> 8;
  addr += ac_pc;
  ac_pc = npc;

  if (PSRicc_C == 0) 
  {
	 npc = addr;
  } else {
    npc = npc + 4;
    if(an){
      ac_pc = npc;
      npc = npc + 4; //!Delay slot annuled
    }
  }
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("bcc%s 0x%x\n",an_s[an], ac_pc.read());
  #endif
}

//!Instruction bcs behavior method.
void ac_behavior( bcs ){
  uint32_t addr = (disp22 << 10) >> 8;
  addr += ac_pc;
  ac_pc = npc;

  if (PSRicc_C == 1) 
  {
	 npc = addr;
  } else {
    npc = npc + 4;
    if(an){
      ac_pc = npc;
      npc = npc + 4; //!Delay slot annuled
    }
  }
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("bcs%s 0x%x\n",an_s[an], ac_pc.read());
  #endif
}

//!Instruction bpos behavior method.
void ac_behavior( bpos ){
  uint32_t addr = (disp22 << 10) >> 8;
  addr += ac_pc;
  ac_pc = npc;

  if (PSRicc_N == 0) 
  {
	 npc = addr;
  } else {
    npc = npc + 4;
    if(an){
      ac_pc = npc;
      npc = npc + 4; //!Delay slot annuled
    }
  }
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("bpos%s 0x%x\n",an_s[an], ac_pc.read());
  #endif
}

//!Instruction bneg behavior method.
void ac_behavior( bneg ){
  uint32_t addr = (disp22 << 10) >> 8;
  addr += ac_pc;
  ac_pc = npc;

  if (PSRicc_N == 1) 
  {
	 npc = addr;
  } else {
    npc = npc + 4;
    if(an){
      ac_pc = npc;
      npc = npc + 4; //!Delay slot annuled
    }
  }
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("bneg%s 0x%x\n",an_s[an], ac_pc.read());
  #endif
}

//!Instruction bvc behavior method.
void ac_behavior( bvc ){
  uint32_t addr = (disp22 << 10) >> 8;
  addr += ac_pc;
  ac_pc = npc;

  if (PSRicc_V == 0) 
  {
	 npc = addr;
  } else {
    npc = npc + 4;
    if(an){
      ac_pc = npc;
      npc = npc + 4; //!Delay slot annuled
    }
  }
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("bvc%s 0x%x\n",an_s[an], ac_pc.read());
  #endif
}

//!Instruction bvs behavior method.
void ac_behavior( bvs ){
  uint32_t addr = (disp22 << 10) >> 8;
  addr += ac_pc;
  ac_pc = npc;

  if (PSRicc_V == 1) 
  {
	 npc = addr;
  } else {
    npc = npc + 4;
    if(an){
      ac_pc = npc;
      npc = npc + 4; //!Delay slot annuled
    }
  }
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("bvs%s 0x%x\n",an_s[an], ac_pc.read());
  #endif
}

//!Instruction ldsb_reg behavior method.
void ac_behavior( ldsb_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("ldsb [%s + %s], %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif

  #ifdef WITH_SRMMU
   MEM.write(0x90000000, (PSR.read() & 0x80) ? 0xB : 0xA);
  #endif
  int32_t data = (int32_t)(int8_t) MEM.read_byte(readReg(rs1) + readReg(rs2));
  //!Check for any memory access errors
  if(!trap_selector.is_trap_mode())
  {
     writeReg(rd, data);
     ac_pc = npc;
     npc = npc + 4;
  }
}

//!Instruction ldsh_reg behavior method.
void ac_behavior( ldsh_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("ldsh [%s + %s], %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif

  #ifdef WITH_SRMMU
   MEM.write(0x90000000, (PSR.read() & 0x80) ? 0xB : 0xA);
  #endif

  uint32_t addr = readReg(rs1) + readReg(rs2);
  int32_t  data = 0;

  if (addr & 0x1)
  {
     trap_selector.set_mem_address_not_aligned(true);
  } else {
     data = (int32_t)(int16_t) MEM.read_half(addr);
	  if(!trap_selector.is_trap_mode())
	  {
		  writeReg(rd, data);
		  ac_pc = npc;
		  npc = npc + 4;
	  }
  }
}

//!Instruction ldub_reg behavior method.
void ac_behavior( ldub_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("ldub [%s + %s], %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif

  #ifdef WITH_SRMMU
  MEM.write(0x90000000, (PSR.read() & 0x80) ? 0xB : 0xA);
  #endif

  uint32_t addr = readReg(rs1) + readReg(rs2);
  uint32_t data = MEM.read_byte(addr);

  if(!trap_selector.is_trap_mode())
  {
     writeReg(rd, data);
     ac_pc = npc;
     npc = npc + 4;
  }
}

//!Instruction lduh_reg behavior method.
void ac_behavior( lduh_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("lduh [%s + %s], %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif

  #ifdef WITH_SRMMU
  MEM.write(0x90000000, (PSR.read() & 0x80) ? 0xB : 0xA);
  #endif
  
  uint32_t addr = readReg(rs1) + readReg(rs2);
  uint32_t data = 0;

  if (addr & 0x1)
  {
     trap_selector.set_mem_address_not_aligned(true);
  } else { 
     data = MEM.read_half(addr);
	  if(!trap_selector.is_trap_mode())
	  {
		  writeReg(rd, data);
		  ac_pc = npc;
		  npc = npc + 4;
	  }
  }
}

//!Instruction ld_reg behavior method.
void ac_behavior( ld_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("ld [%s + %s], %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif

  #ifdef WITH_SRMMU
  MEM.write(0x90000000, (PSR.read() & 0x80) ? 0xB : 0xA);
  #endif

  uint32_t addr = readReg(rs1) + readReg(rs2);
  uint32_t data = 0;

  if (addr & 0x3)
  {
     trap_selector.set_mem_address_not_aligned(true);
  } else { 
     data = MEM.read(addr);
	  if(!trap_selector.is_trap_mode())
	  {
		  writeReg(rd, data);
		  ac_pc = npc;
		  npc = npc + 4;
	  }
  }
}

//!Instruction ldd_reg behavior method.
void ac_behavior( ldd_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("ldd [%s + %s], %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif

  #ifdef WITH_SRMMU
  MEM.write(0x90000000, (PSR.read() & 0x80) ? 0xB : 0xA);
  #endif

  uint32_t addr = readReg(rs1) + readReg(rs2);
  uint32_t data_0 = 0;
  uint32_t data_1 = 0;
  
  if (rd & 0x1)
  {
     trap_selector.set_illegal_instruction(true); 
  } else if (addr & 0x7) {
     trap_selector.set_mem_address_not_aligned(true);
  } else {
     data_0 = MEM.read(addr);
     if (!trap_selector.is_trap_mode())
     {
        data_1 = MEM.read(addr + 4);
        if (!trap_selector.is_trap_mode())
        {
				writeReg(rd, data_0);
            writeReg(rd + 1, data_1);
            ac_pc = npc;
            npc   = npc + 4;
        }
     }
  }
}

//!Instruction lduba behavior method.
void ac_behavior( lduba ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("lduba [%s + %s], 0x%x, %s\n", reg_alias[rs1], reg_alias[rs2], asi, reg_alias[rd]);
  #endif
  if (is == 1)
  {
    trap_selector.set_illegal_instruction(true); 
  } else if (PSR_S == 0)
  {
    trap_selector.set_privileged_instruction(true); 
  } else {

	 #ifdef WITH_SRMMU
	 MEM.write(0x90000000,asi);
	 #endif

	 uint32_t data = MEM.read_byte(readReg(rs1) + readReg(rs2));
	 if(!trap_selector.is_trap_mode())
	 {
      writeReg(rd, data);
		ac_pc = npc;
		npc = npc + 4;
	 }
  }
}

//!Instruction lduha behavior method.
void ac_behavior( lduha ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("lduha [%s + %s], 0x%x, %s\n", reg_alias[rs1], reg_alias[rs2], asi, reg_alias[rd]);
  #endif
  if (is == 1)
  {
    trap_selector.set_illegal_instruction(true); 
  } else if (PSR_S == 0)
  {
    trap_selector.set_privileged_instruction(true); 
  } else {
    uint32_t addr = readReg(rs1) + readReg(rs2);
    if(addr & 0x1)
    {
      trap_selector.set_mem_address_not_aligned(true); 
    } else {    

	   #ifdef WITH_SRMMU
	   MEM.write(0x90000000,asi);
	   #endif

      uint32_t data = MEM.read_half(addr);
	   if(!trap_selector.is_trap_mode())
	   {
		  writeReg(rd, data);
		  ac_pc = npc;
	     npc = npc + 4;
	   }     
    }
  }
}

//!Instruction lda behavior method.
void ac_behavior( lda ){
  #ifdef PRINT_INSTRUCTION
  dbg_printf("ld [%s + %s], %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif

  if (is == 1)
  {
    trap_selector.set_illegal_instruction(true); 
  } else if (PSR_S == 0)
  {
    trap_selector.set_privileged_instruction(true); 
  } else {

	 uint32_t addr = readReg(rs1) + readReg(rs2);
	 uint32_t data = 0;

	 if (addr & 0x3)
	 {
		  trap_selector.set_mem_address_not_aligned(true);
	 } else { 

	     #ifdef WITH_SRMMU
	     MEM.write(0x90000000, asi);
	     #endif

		  data = MEM.read(addr);
		  if(!trap_selector.is_trap_mode())
		  {
			  writeReg(rd, data);
			  ac_pc = npc;
			  npc = npc + 4;
		  }
	 }
  }
}

//!Instruction ldda behavior method.
void ac_behavior( ldda ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("ldda [%s + %s], %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif
  uint32_t addr = readReg(rs1) + readReg(rs2);
  uint32_t data_0 = 0;
  uint32_t data_1 = 0;

  if (is == 1)
  {
    trap_selector.set_illegal_instruction(true); 
  } else if (PSR_S == 0)
  {
    trap_selector.set_privileged_instruction(true); 
  } else {

	 if (rd & 0x1)
	 {
		  trap_selector.set_illegal_instruction(true); 
	 } else if (addr & 0x7) {
		  trap_selector.set_mem_address_not_aligned(true);
	 } else {
	     #ifdef WITH_SRMMU
	     MEM.write(0x90000000,asi);
	     #endif
		  data_0 = MEM.read(addr);
		  if (!trap_selector.is_trap_mode())
		  {
		     data_1 = MEM.read(addr + 4);
		     if (!trap_selector.is_trap_mode())
		     {
					writeReg(rd, data_0);
		         writeReg(rd + 1, data_1);
		         ac_pc = npc;
		         npc   = npc + 4;
		     }
		  }
	  }
  }
}

//!Instruction stba behavior method.
void ac_behavior( stba ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("stba %s, [%s + %s], 0x%x\n", reg_alias[rd], reg_alias[rs1], reg_alias[rs2], asi);
  #endif
  if (is == 1)
  {
     trap_selector.set_illegal_instruction(true); 
  } else if (PSR_S == 0)
  {
     trap_selector.set_privileged_instruction(true); 
  } else {

	  #ifdef WITH_SRMMU
	  MEM.write(0x90000000, asi);
	  #endif
	  
	  uint32_t addr = readReg(rs1) + readReg(rs2);
	  MEM.write_byte(addr, (int8_t) readReg(rd));

	  if(!trap_selector.is_trap_mode())
	  {
		  ac_pc = npc;
		  npc = npc + 4;
	  }
  }
}

//!Instruction stha behavior method.
void ac_behavior( stha ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("stha %s, [%s + %s], 0x%x\n", reg_alias[rd], reg_alias[rs1], reg_alias[rs2], asi);
  #endif
  uint32_t addr = readReg(rs1) + readReg(rs2);

  if (is == 1)
  {
    trap_selector.set_illegal_instruction(true); 
  } else if (PSR_S == 0)
  {
    trap_selector.set_privileged_instruction(true); 
  } else if(addr & 0x1)
  {
	  trap_selector.set_mem_address_not_aligned(true);
  } else {
     #ifdef WITH_SRMMU
     MEM.write(0x90000000, asi);
     #endif
     MEM.write_half(addr, (int16_t) readReg(rd));
	  if(!trap_selector.is_trap_mode())
	  {
		  ac_pc = npc;
		  npc = npc + 4;
	  }
  }
}

//!Instruction sta behavior method.
void ac_behavior( sta ){
  #ifdef PRINT_INSTRUCTION
  dbg_printf("sta %s, [%s + %s], 0x%x\n", reg_alias[rd], reg_alias[rs1], reg_alias[rs2], asi);
  #endif

  uint32_t addr = readReg(rs1) + readReg(rs2);

  if (is == 1)
  {
    trap_selector.set_illegal_instruction(true); 
  } else if (PSR_S == 0)
  {
    trap_selector.set_privileged_instruction(true); 
  } else if(addr & 0x3)
  {
	  trap_selector.set_mem_address_not_aligned(true);
  } else {  
     #ifdef WITH_SRMMU
     MEM.write(0x90000000, asi);
     #endif
     MEM.write(addr, readReg(rd));
	  if(!trap_selector.is_trap_mode())
	  {
		  ac_pc = npc;
		  npc = npc + 4;
	  }
  }
}

//!Instruction stda behavior method.
void ac_behavior( stda ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("stda %s, [%s + %s], 0x%x\n", reg_alias[rd], reg_alias[rs1], reg_alias[rs2], asi);
  #endif
  uint32_t addr = readReg(rs1) + readReg(rs2);
  uint32_t data_0 = 0;
  uint32_t data_1 = 0;

  if (is == 1)
  {
    trap_selector.set_illegal_instruction(true); 
  } else if (PSR_S == 0)
  {
    trap_selector.set_privileged_instruction(true); 
  } else if (rd & 0x1) {
     trap_selector.set_illegal_instruction(true); 
  } else if (addr & 0x7) {
     trap_selector.set_mem_address_not_aligned(true);
  } else {
     #ifdef WITH_SRMMU
     MEM.write(0x90000000, asi);
     #endif

     MEM.write(addr, readReg(rd));
     if(!trap_selector.is_trap_mode())
     {
        MEM.write(addr + 4, readReg(rd + 1));
		  if(!trap_selector.is_trap_mode())
		  {
		    ac_pc = npc;
		    npc = npc + 4;
		  }
     }
  }
}

//!Instruction ldstuba behavior method.
void ac_behavior( ldstuba ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("ldstuba %s, [%s + %s]\n", reg_alias[rd], reg_alias[rs1], reg_alias[rs2]);
  #endif
  if (is == 1)
  {
    trap_selector.set_illegal_instruction(true); 
  } else if (PSR_S == 0) {
    trap_selector.set_privileged_instruction(true); 
  } else {
    //!wait for lock(s) to be lifted
    while ((pb_block_ldst_byte == 1) || (pb_block_ldst_word == 1)) 
    {
     /*
       an implementation actually need only block when another LDSTUB or SWAP
      is pending on the same byte in memory as the one addressed by this LDSTUB
    */
    }

    #ifdef WITH_SRMMU
    if(asi == 0x1) //DATA CACHE FORCE MISS
       asi = (PSR.read() & 0x80) ? 0xB : 0xA;
    MEM.write(0x90000000, asi);
    #endif

    //!Acquire the lock
    pb_block_ldst_byte = 1;

    uint32_t addr = readReg(rs1) + readReg(rs2);
    uint32_t data = MEM.read_byte(addr);

    //!Release the lock
    pb_block_ldst_byte = 0;

    if(!trap_selector.is_trap_mode())
    { 
      MEM.write_byte(addr, 0xFF);

      if(!trap_selector.is_trap_mode())
      {
        writeReg(rd, data & 0xFF);
        ac_pc = npc;
        npc = npc + 4;
      }
    }
  } //else
}

//!Instruction ldsha behavior method.
void ac_behavior( ldsha ){
  //TODO:
  printf("unimplemented instruction ldsha\n");
  stop(EXIT_FAILURE);
}

//!Instruction ldsba behavior method.
void ac_behavior( ldsba ){
  //TODO:
  printf("unimplemented instruction ldsba\n");
  stop(EXIT_FAILURE);
}

//!Instruction swapa behavior method.
void ac_behavior( swapa ){
  //TODO:
  printf("unimplemented instruction swapa\n");
  stop(EXIT_FAILURE);
}

//!Instruction stb_reg behavior method.
void ac_behavior( stb_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("stb %s, [%s + %s]\n", reg_alias[rd], reg_alias[rs1], reg_alias[rs2]);
  #endif
  #ifdef WITH_SRMMU
  MEM.write(0x90000000, (PSR.read() & 0x80) ? 0xB : 0xA);
  #endif
  
  uint32_t addr = readReg(rs1) + readReg(rs2);
  MEM.write_byte(addr, readReg(rd) & 0xFF);

  if(!trap_selector.is_trap_mode())
  {
     ac_pc = npc;
     npc = npc + 4;
  }
}

//!Instruction sth_reg behavior method.
void ac_behavior( sth_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("sth %s, [%s + %s]\n", reg_alias[rd], reg_alias[rs1], reg_alias[rs2]);
  #endif

  #ifdef WITH_SRMMU
  MEM.write(0x90000000, (PSR.read() & 0x80) ? 0xB : 0xA);
  #endif
  
  uint32_t addr = readReg(rs1) + readReg(rs2);

  if(addr & 0x1)
  {
	  trap_selector.set_mem_address_not_aligned(true);
  } else {
     MEM.write_half(addr, readReg(rd) & 0xFFFF);
	  if(!trap_selector.is_trap_mode())
	  {
		  ac_pc = npc;
		  npc = npc + 4;
	  }
  }
}

//!Instruction st_reg behavior method.
void ac_behavior( st_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("st %s, [%s + %s]\n", reg_alias[rd], reg_alias[rs1], reg_alias[rs2]);
  #endif

  #ifdef WITH_SRMMU
  MEM.write(0x90000000, (PSR.read() & 0x80) ? 0xB : 0xA);
  #endif

  uint32_t addr = readReg(rs1) + readReg(rs2);
  
  if(addr & 0x3)
  {
	  trap_selector.set_mem_address_not_aligned(true);
  } else {  
     MEM.write(addr, readReg(rd));
	  if(!trap_selector.is_trap_mode())
	  {
		  ac_pc = npc;
		  npc = npc + 4;
	  }
  }
}

//!Instruction std_reg behavior method.
void ac_behavior( std_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("std %s, [%s + %s]\n", reg_alias[rd], reg_alias[rs1], reg_alias[rs2]);
  #endif

  #ifdef WITH_SRMMU
  MEM.write(0x90000000, (PSR.read() & 0x80) ? 0xB : 0xA);
  #endif

  uint32_t addr = readReg(rs1) + readReg(rs2);
  uint32_t data_0 = 0;
  uint32_t data_1 = 0;

  if (rd & 0x1)
  {
     trap_selector.set_illegal_instruction(true); 
  } else if (addr & 0x7) {
     trap_selector.set_mem_address_not_aligned(true);
  } else {
     MEM.write(addr, readReg(rd));
     if(!trap_selector.is_trap_mode())
     {
        MEM.write(addr + 4, readReg(rd + 1));
		  if(!trap_selector.is_trap_mode())
		  {
		    ac_pc = npc;
		    npc = npc + 4;
		  }
     }
  }
}

//!Instruction ldstub_reg behavior method.
void ac_behavior( ldstub_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("ldstub %s, [%s + %s]\n", reg_alias[rd], reg_alias[rs1], reg_alias[rs2]);
  #endif
  //!wait for lock(s) to be lifted
  while ((pb_block_ldst_byte == 1) || (pb_block_ldst_word == 1)) 
  {
   /*
	   an implementation actually need only block when another LDSTUB or SWAP
		is pending on the same byte in memory as the one addressed by this LDSTUB
	*/
  }

  #ifdef WITH_SRMMU
  MEM.write(0x90000000, (PSR.read() & 0x80) ? 0xB : 0xA);
  #endif

  //!Acquire the lock
  pb_block_ldst_byte = 1;

  uint32_t addr = readReg(rs1) + readReg(rs2);
  uint32_t data = MEM.read_byte(addr);

  //!Release the lock
  pb_block_ldst_byte = 0;
  
  if(!trap_selector.is_trap_mode())
  { 
     MEM.write_byte(addr, 0xFF);

	  if(!trap_selector.is_trap_mode())
	  {
		  writeReg(rd, data & 0xFF);
		  ac_pc = npc;
		  npc = npc + 4;
	  }
  }
}

//!Instruction swap_reg behavior method.
void ac_behavior( swap_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("swap %s, [%s + %s]\n", reg_alias[rd], reg_alias[rs1], reg_alias[rs2]);
  #endif
  uint32_t temp = readReg(rd);
  //!wait for lock(s) to be lifted
  while ((pb_block_ldst_byte == 1) || (pb_block_ldst_word == 1)) 
  {
   /*
	   an implementation actually need only block when another LDSTUB or SWAP
		is pending on the same byte in memory as the one addressed by this LDSTUB
	*/
  }

  #ifdef WITH_SRMMU
  MEM.write(0x90000000, (PSR.read() & 0x80) ? 0xB : 0xA);
  #endif

  //!Acquire the lock
  pb_block_ldst_word = 1;

  uint32_t addr = readReg(rs1) + readReg(rs2);
  uint32_t data = MEM.read(addr);

  //!Release the lock
  pb_block_ldst_word = 0;
  
  if(!trap_selector.is_trap_mode())
  { 
     MEM.write(addr, temp);

	  if(!trap_selector.is_trap_mode())
	  {
		  writeReg(rd, data);
		  ac_pc = npc;
		  npc = npc + 4;
	  }
  }
}

//!Instruction sll_reg behavior method.
void ac_behavior( sll_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("sll %s, %s, %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif
  writeReg(rd, readReg(rs1) << readReg(rs2));
  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction srl_reg behavior method.
void ac_behavior( srl_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("srl %s, %s, %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif
  writeReg(rd, ((uint32_t) readReg(rs1)) >> ((uint32_t) readReg(rs2)));
  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction sra_reg behavior method.
void ac_behavior( sra_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("sra %s, %s, %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif
  writeReg(rd, ((int32_t) readReg(rs1)) >> ((int32_t) readReg(rs2)));
  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction add_reg behavior method.
void ac_behavior( add_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("add %s, %s, %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif
  writeReg(rd, readReg(rs1) + readReg(rs2));
  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction addcc_reg behavior method.
void ac_behavior( addcc_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("addcc %s, %s, %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif

  uint32_t dest = readReg(rs1) + readReg(rs2);

  //!Update PSR integer condition codes
  SET_PSRicc_N(dest >> 31);
  SET_PSRicc_Z(dest == 0);
  SET_PSRicc_V((bit((readReg(rs1) &  readReg(rs2) & ~dest) |
	                 (~readReg(rs1) & ~readReg(rs2) &  dest) , 31)));
  SET_PSRicc_C((bit((readReg(rs1) & readReg(rs2)) |
	                 (~dest & (readReg(rs1) | readReg(rs2))), 31)));
  
  writeReg(rd, dest);

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction addx_reg behavior method.
void ac_behavior( addx_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("addx %s, %s, %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif
  writeReg(rd, readReg(rs1) + readReg(rs2) + PSRicc_C);

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction addxcc_reg behavior method.
void ac_behavior( addxcc_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("addxcc %s, %s, %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif
  uint32_t dest = readReg(rs1) + readReg(rs2) + PSRicc_C;

  //!Update PSR integer condition codes
  SET_PSRicc_N(dest >> 31);
  SET_PSRicc_Z(dest == 0);
  SET_PSRicc_V((bit((readReg(rs1) &  readReg(rs2) & ~dest) |
	                 (~readReg(rs1) & ~readReg(rs2) &  dest) , 31)));
  SET_PSRicc_C((bit((readReg(rs1) & readReg(rs2)) |
	                 (~dest & (readReg(rs1) | readReg(rs2))), 31)));
  
  writeReg(rd, dest);

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction taddcc_reg behavior method.
void ac_behavior( taddcc_reg ){
  //TODO:
  printf("unimplemented instruction taddcctv_reg\n");
  stop(EXIT_FAILURE);
}

//!Instruction taddcctv_reg behavior method.
void ac_behavior( taddcctv_reg ){
  //TODO:
  printf("unimplemented instruction taddcctv_reg\n");
  stop(EXIT_FAILURE);
}

//!Instruction sub_reg behavior method.
void ac_behavior( sub_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("sub %s, %s, %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif
  writeReg(rd, (readReg(rs1) - readReg(rs2)));
  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction subcc_reg behavior method.
void ac_behavior( subcc_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("subcc %s, %s, %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif
  uint32_t dest = readReg(rs1) - readReg(rs2);

  //!Update PSR integer condition codes
  SET_PSRicc_N(dest >> 31);
  SET_PSRicc_Z(dest == 0);
  SET_PSRicc_V((bit((readReg(rs1) &  ~readReg(rs2) & ~dest) |
	                 (~readReg(rs1) & readReg(rs2) &  dest) , 31)));
  SET_PSRicc_C((bit((~readReg(rs1) & readReg(rs2)) |
	                 (dest & (~readReg(rs1) | readReg(rs2))), 31)));
  
  writeReg(rd, dest);

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction subx_reg behavior method.
void ac_behavior( subx_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("subx %s, %s, %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif
  writeReg(rd, readReg(rs1) - readReg(rs2) - PSRicc_C);

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction subxcc_reg behavior method.
void ac_behavior( subxcc_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("subxcc %s, %s, %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif
  uint32_t dest = readReg(rs1) - readReg(rs2) - PSRicc_C;

  //!Update PSR integer condition codes
  SET_PSRicc_N(dest >> 31);
  SET_PSRicc_Z(dest == 0);
  SET_PSRicc_V((bit((readReg(rs1) &  ~readReg(rs2) & ~dest) |
	                 (~readReg(rs1) & readReg(rs2) &  dest) , 31)));
  SET_PSRicc_C((bit((~readReg(rs1) & readReg(rs2)) |
	                 (dest & (~readReg(rs1) | readReg(rs2))), 31)));
  
  writeReg(rd, dest);

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction tsubcc_reg behavior method.
void ac_behavior( tsubcc_reg ){
  //TODO:
  printf("unimplemented instruction tsubcc_reg\n");
  stop(EXIT_FAILURE);
}

//!Instruction tsubcctv_reg behavior method.
void ac_behavior( tsubcctv_reg ){
  //TODO:
  printf("unimplemented instruction tsubcctv_reg\n");
  stop(EXIT_FAILURE);
}

//!Instruction and_reg behavior method.
void ac_behavior( and_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("and %s, %s, %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif
  writeReg(rd, readReg(rs1) & readReg(rs2));

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction andcc_reg behavior method.
void ac_behavior( andcc_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("andcc %s, %s, %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif
  uint32_t dest = readReg(rs1) & readReg(rs2);

  //!Update PSR integer condition codes
  SET_PSRicc_N(dest >> 31);
  SET_PSRicc_Z(dest == 0);
  SET_PSRicc_V(0);
  SET_PSRicc_C(0);
  
  writeReg(rd, dest);

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction andn_reg behavior method.
void ac_behavior( andn_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("andn %s, %s, %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif
  writeReg(rd, readReg(rs1) & ~readReg(rs2));

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction andncc_reg behavior method.
void ac_behavior( andncc_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("andncc %s, %s, %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif
  uint32_t dest = readReg(rs1) & ~readReg(rs2);

  //!Update PSR integer condition codes
  SET_PSRicc_N(dest >> 31);
  SET_PSRicc_Z(dest == 0);
  SET_PSRicc_V(0);
  SET_PSRicc_C(0);
  
  writeReg(rd, dest);

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction or_reg behavior method.
void ac_behavior( or_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("or %s, %s, %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif
  writeReg(rd, readReg(rs1) | readReg(rs2));

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction orcc_reg behavior method.
void ac_behavior( orcc_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("orcc %s, %s, %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif
  uint32_t dest = readReg(rs1) | readReg(rs2);

  //!Update PSR integer condition codes
  SET_PSRicc_N(dest >> 31);
  SET_PSRicc_Z(dest == 0);
  SET_PSRicc_V(0);
  SET_PSRicc_C(0);
  
  writeReg(rd, dest);

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction orn_reg behavior method.
void ac_behavior( orn_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("orn %s, %s, %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif
  writeReg(rd, readReg(rs1) | ~readReg(rs2));

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction orncc_reg behavior method.
void ac_behavior( orncc_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("orncc %s, %s, %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif
  uint32_t dest = readReg(rs1) | ~readReg(rs2);

  //!Update PSR integer condition codes
  SET_PSRicc_N(dest >> 31);
  SET_PSRicc_Z(dest == 0);
  SET_PSRicc_V(0);
  SET_PSRicc_C(0);
  
  writeReg(rd, dest);

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction xor_reg behavior method.
void ac_behavior( xor_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("xor %s, %s, %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif
  writeReg(rd, readReg(rs1) ^ readReg(rs2));

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction xorcc_reg behavior method.
void ac_behavior( xorcc_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("xorcc %s, %s, %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif

  int dest = readReg(rs1) ^ readReg(rs2);

  //!Update PSR integer condition codes
  SET_PSRicc_N(dest >> 31);
  SET_PSRicc_Z(dest == 0);
  SET_PSRicc_V(0);
  SET_PSRicc_C(0);
  
  writeReg(rd, dest);

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction xnor_reg behavior method.
void ac_behavior( xnor_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("xnor %s, %s, %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif
  writeReg(rd, ~(readReg(rs1) ^ readReg(rs2)));

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction xnorcc_reg behavior method.
void ac_behavior( xnorcc_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("xnorcc %s, %s, %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif
  int dest = ~(readReg(rs1) ^ readReg(rs2));

  //!Update PSR integer condition codes
  SET_PSRicc_N(dest >> 31);
  SET_PSRicc_Z(dest == 0);
  SET_PSRicc_V(0);
  SET_PSRicc_C(0);
  
  writeReg(rd, dest);

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction save_reg behavior method.
void ac_behavior( save_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("save %s, %s, %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif

  int result;
  uint32_t new_CWP = (uint32_t)((PSR_CWP) - 1) % NWINDOWS;

  if (WIM.read() & (1 << new_CWP)){
     trap_selector.set_window_overflow(true);
  }else{
      result = readReg(rs1) + readReg(rs2);//!source operands are read from old window
      SET_PSR_CWP(new_CWP);
      writeReg(rd, result);
      ac_pc = npc;
      npc = npc + 4;
  }
}

//!Instruction restore_reg behavior method.
void ac_behavior( restore_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("restore %s, %s, %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif

  int result;
  uint32_t new_CWP = (uint32_t)((PSR_CWP) + 1) % NWINDOWS;


  if (WIM.read()  & (1 << new_CWP)){
     trap_selector.set_window_underflow(true);
  }else{
      result = readReg(rs1) + readReg(rs2);
      SET_PSR_CWP(new_CWP);
      writeReg(rd, result);
      ac_pc = npc;
      npc = npc + 4;
  }
}

//!Instruction umul_reg behavior method.
void ac_behavior( umul_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("umul %s, %s, %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif

  uint64_t tmp = (uint64_t) readReg(rs1) * (uint64_t) readReg(rs2);
  writeReg(rd, (uint32_t) tmp);
  Y.write((uint32_t) (tmp >> 32));

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction smul_reg behavior method.
void ac_behavior( smul_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("smul %s, %s, %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif
  int64_t tmp = (int64_t) readReg(rs1) * (int64_t) readReg(rs2);
  writeReg(rd, (int32_t) tmp);
  Y.write((int32_t) (tmp >> 32));

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction umulcc_reg behavior method.
void ac_behavior( umulcc_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("umulcc %s, %s, %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif
  uint64_t tmp = (uint64_t) readReg(rs1) * (uint64_t) readReg(rs2);

  //!Update PSR integer condition codes
  SET_PSRicc_N((uint32_t) tmp >> 31);
  SET_PSRicc_Z((uint32_t) tmp == 0);
  SET_PSRicc_V(0);
  SET_PSRicc_C(0);
  
  writeReg(rd, (uint32_t) tmp);
  Y.write((uint32_t) (tmp >> 32));

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction smulcc_reg behavior method.
void ac_behavior( smulcc_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("smulcc %s, %s, %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif
  int64_t tmp = (int64_t) readReg(rs1) * (int64_t) readReg(rs2);

  //!Update PSR integer condition codes
  SET_PSRicc_N((uint32_t) tmp >> 31);
  SET_PSRicc_Z((uint32_t) tmp == 0);
  SET_PSRicc_V(0);
  SET_PSRicc_C(0);
  
  writeReg(rd, (int32_t) tmp);
  Y.write((int32_t) (tmp >> 32));

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction mulscc_reg behavior method.
void ac_behavior( mulscc_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("mulscc %s, %s, %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif

  int32_t rs1_0 = readReg(rs1) & 1;

  int32_t op1 = ((PSRicc_N ^ PSRicc_V) << 31) | (readReg(rs1) >> 1);
  int32_t op2 = (Y.read() & 1) == 0 ? 0 : (readReg(rs2));
  

  int32_t result = op1 + op2;

  //!Update PSR integer condition codes
  SET_PSRicc_N(result >> 31);
  SET_PSRicc_Z(result == 0);
  SET_PSRicc_V((bit((( op1 &  op2 & ~result) |
	            (~op1 & ~op2 &  result)), 31)));
  SET_PSRicc_C((bit(((op1 &  op2) |
	            (~result & (op1 | op2))), 31)));

  writeReg(rd, result);
  Y.write((rs1_0 << 31) | (Y.read() >> 1));
  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction udiv_reg behavior method.
void ac_behavior( udiv_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("udiv %s, %s, %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif

  uint64_t tmp;
    
  tmp = (uint64_t) Y.read() << 32;
  tmp |= (uint32_t) readReg(rs1);
  
  //!division by zero
  if(readReg(rs2) == 0)
  {
    trap_selector.set_division_by_zero(true);
  }else{
    tmp /= (uint32_t) readReg(rs2);
    uint32_t result;

    //!result overflowed 32 bits; return largest appropriate integer 
    result = (uint32_t) ((tmp >> 32) == 0) ? tmp & 0xFFFFFFFF : 0xFFFFFFFF;
    writeReg(rd, result);

    ac_pc = npc;
    npc = npc + 4;
  }
}

//!Instruction udivcc_reg behavior method.
void ac_behavior( udivcc_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("udivcc %s, %s, %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif
  uint64_t tmp;
    
  tmp =  (uint64_t) Y.read() << 32;
  tmp |= (uint32_t) readReg(rs1);
  
  //!division by zero
  if(readReg(rs2) == 0)
  {
    trap_selector.set_division_by_zero(true);
  }else{
    tmp /= (uint32_t) readReg(rs2);
    uint32_t result;

    //!result overflowed 32 bits; return largest appropriate integer 
    result = (uint32_t) ((tmp >> 32) == 0) ? tmp & 0xFFFFFFFF : 0xFFFFFFFF;

    //!Update PSR integer condition codes
    SET_PSRicc_N(result >> 31);
    SET_PSRicc_Z(result == 0);
    SET_PSRicc_V(((tmp >> 32) == 0));
    SET_PSRicc_C(0);

    writeReg(rd, result);

    ac_pc = npc;
    npc = npc + 4;
  }
}

//!Instruction sdiv_reg behavior method.
void ac_behavior( sdiv_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("sdiv %s, %s, %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif

  int64_t tmp;
    
  tmp = (int64_t) Y.read() << 32;
  tmp |= (int32_t) readReg(rs1);
  
  //!division by zero
  if(readReg(rs2) == 0)
  {
    trap_selector.set_division_by_zero(true);
  }else{
    tmp /= (int32_t) readReg(rs2);
    int32_t result = (int32_t) (tmp & 0xFFFFFFFF);
    //!result overflowed 32 bits; return largest appropriate integer 
    bool temp_V = (((tmp >> 31) == 0) |
		 ((tmp >> 31) == -1LL)) ? 0 : 1;
    if (temp_V) {
       if(tmp > 0)
          result = 0x7FFFFFFF; //!2^31 - 1
      else 
          result = 0x80000000; //!-2^31
    }

    writeReg(rd, result);

    ac_pc = npc;
    npc = npc + 4;
  }
}

//!Instruction sdivcc_reg behavior method.
void ac_behavior( sdivcc_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("sdivcc %s, %s, %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif
  int64_t tmp;
    
  tmp = (int64_t) Y.read() << 32;
  tmp |= (int32_t) readReg(rs1);
  
  //!division by zero
  if(readReg(rs2) == 0)
  {
    trap_selector.set_division_by_zero(true);
  }else{
    tmp /= (int32_t) readReg(rs2);
    int32_t result = (int32_t) (tmp & 0xFFFFFFFF);
    //!result overflowed 32 bits; return largest appropriate integer 
    bool temp_V = (((tmp >> 31) == 0) |
		 ((tmp >> 31) == -1LL)) ? 0 : 1;
    if (temp_V) {
       if(tmp > 0)
          result = 0x7FFFFFFF; //!2^31 - 1
      else 
          result = 0x80000000; //!-2^31
    }

    //!Update PSR integer condition codes
    SET_PSRicc_N(result >> 31);
    SET_PSRicc_Z(result == 0);
    SET_PSRicc_V(temp_V);
    SET_PSRicc_C(0);

    writeReg(rd, result);

    ac_pc = npc;
    npc = npc + 4;
  }
}

//!Instruction jmpl_reg behavior method.
void ac_behavior( jmpl_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("jmpl %s, %s, %s\n", reg_alias[rs1], reg_alias[rs2], reg_alias[rd]);
  #endif

  uint32_t addr = readReg(rs1) + readReg(rs2);

  if (addr & 0x3)
  {
    trap_selector.set_mem_address_not_aligned(true);
  }else{ 
    writeReg(rd, ac_pc);

    ac_pc = npc;
    npc = addr;
  }
}

//!Instruction wry_reg behavior method.
void ac_behavior( wry_reg ){
  switch(rd) {
    case 0 : 
       Y.write(readReg(rs1) ^ readReg(rs2));
       #ifdef PRINT_INSTRUCTION  
       dbg_printf("wr %%y, 0x%x\n",readReg(rs1) ^ simm13 );
       #endif
    break;
    case 1 ... 31 :
      #ifdef PRINT_INSTRUCTION 
      dbg_printf("rd %%asr%d, %s\n",rs1, reg_alias[rd]);
      #endif
      ASR[rd] = (readReg(rs1) ^ readReg(rs2));
      if(rd == 19)
        printf("power down mode unimplemented %d\n", ASR[19]);
    break;
    default:
      stop(EXIT_FAILURE);
  }
  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction wrtbr_reg behavior method.
void ac_behavior( wrtbr_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("wr %s, %s, %%tbr\n", reg_alias[rs1], reg_alias[rs2]);
  #endif

  if(!PSR_S){
     trap_selector.set_privileged_instruction(true);
  } else {
     TBR.write(readReg(rs1) ^ readReg(rs2));
     ac_pc = npc;
     npc = npc + 4;
  }
}

//!Instruction wrpsr_reg behavior method.
void ac_behavior( wrpsr_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("wr %s, %s, %%psr\n", reg_alias[rs1], reg_alias[rs2]);
  #endif

  if(!PSR_S){
     trap_selector.set_privileged_instruction(true);
  } else {
     uint32_t value = readReg(rs1) ^ readReg(rs2);
     //!Check of new CWP is > the number of windows
     if((value & 0x1f) >= NWINDOWS){ 
        trap_selector.set_illegal_instruction(true);
     } else {
       //!Clear impl and ver bits (hardwired)
       PSR.write((clear_bits(value, 31, 24)));
       ac_pc = npc;
       npc = npc + 4;
     }
  }
}

//!Instruction wrwim_reg behavior method.
void ac_behavior( wrwim_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("wr %s, %s, %%wim\n", reg_alias[rs1], reg_alias[rs2]);
  #endif

  if(PSR_S){
     uint32_t value = readReg(rs1) ^ readReg(rs2);
     //!don't write bits corresponding to non-existent windows
     WIM.write(value << (31 - NWINDOWS-1) >> (31 - NWINDOWS - 1));
     ac_pc = npc;
     npc = npc + 4;
  } else { 
     trap_selector.set_privileged_instruction(true); 
  }
}

//!Instruction rett_reg behavior method.
void ac_behavior( rett_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("rett [%s + %s]\n", reg_alias[rs1], reg_alias[rs2]);
  #endif

  uint32_t new_CWP = (uint32_t)((PSR.read() & 0x1f) + 1) % NWINDOWS;
  uint32_t address = readReg(rs1) + readReg(rs2);

  if (PSR_ET){
     if(!PSR_S){
        trap_selector.set_privileged_instruction(true);
     }else{
        trap_selector.set_illegal_instruction(true);
     }
  }else if(!PSR_S){
     trap_selector.set_privileged_instruction(true);
     error_mode = true;
  }else if(WIM & (1 << new_CWP)){
     trap_selector.set_window_underflow(true);
     error_mode = true;
  }else if((address & 0x3) != 0){
     trap_selector.set_mem_address_not_aligned(true);
     error_mode = true;
  }else{
     ac_pc = npc;
     npc = address;
     SET_PSR_S(PSR_PS);
     SET_PSR_ET(1);
     SET_PSR_CWP(new_CWP);
  }
}

//!Instruction flush_reg behavior method.
void ac_behavior( flush_reg ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("flush [%s + %s]\n",reg_alias[rs1], reg_alias[rs2]);
  #endif
  /*
    If the FLUSH instruction is unimplemented, one of either illegal_instruction trap
    or unimplemented_FLUSH trap (at the implementerâ€™s discretion) will result.
    NOTE: On LEON3 the instruction behave like a NOP. If we try to throw a trap we get a 
    unimplemented intruction for some reason and the simulation stop.
  */
  #ifdef FLUSH_NOP
  ac_pc = npc;
  npc = npc + 4;
  #elif FLUSH_TRAP
  trap_selector.set_unimplemented_FLUSH( true );
  #elif FLUSH_ILLEGAL
  trap_selector.set_illegal_instruction( true );
  #endif  
}

//!Instruction ldfsr_reg behavior method.
void ac_behavior( ldfsr_reg ){
  /*FPU Disabled for now*/
  trap_selector.set_fp_disabled(true);
}

//!Instruction ldsb_imm behavior method.
void ac_behavior( ldsb_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("ldsb [%s + 0x%x], %s\n", reg_alias[rs1], simm13, reg_alias[rd]);
  #endif

  #ifdef WITH_SRMMU
   MEM.write(0x90000000, (PSR.read() & 0x80) ? 0xB : 0xA);
  #endif
  
  int32_t data = (int32_t)(int8_t) MEM.read_byte(readReg(rs1) + simm13);
  //!Check for any memory access errors
  if(!trap_selector.is_trap_mode())
  {
     writeReg(rd, data);
     ac_pc = npc;
     npc = npc + 4;
  }
}

//!Instruction ldsh_imm behavior method.
void ac_behavior( ldsh_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("ldsh [%s + 0x%x], %s\n", reg_alias[rs1], simm13, reg_alias[rd]);
  #endif

  #ifdef WITH_SRMMU
   MEM.write(0x90000000, (PSR.read() & 0x80) ? 0xB : 0xA);
  #endif

  uint32_t addr = readReg(rs1) + simm13;
  int32_t  data = 0;

  if (addr & 0x1)
  {
     trap_selector.set_mem_address_not_aligned(true);
  } else {
     data = (int32_t)(int16_t) MEM.read_half(addr);
	  if(!trap_selector.is_trap_mode())
	  {
		  writeReg(rd, data);
		  ac_pc = npc;
		  npc = npc + 4;
	  }
  }
}

//!Instruction ldub_imm behavior method.
void ac_behavior( ldub_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("ldub [%s + 0x%x], %s\n", reg_alias[rs1], simm13, reg_alias[rd]);
  #endif

  #ifdef WITH_SRMMU
  MEM.write(0x90000000, (PSR.read() & 0x80) ? 0xB : 0xA);
  #endif

  uint32_t addr = readReg(rs1) + simm13;
  uint32_t data = MEM.read_byte(addr);

  if(!trap_selector.is_trap_mode())
  {
     writeReg(rd, data);
     ac_pc = npc;
     npc = npc + 4;
  }
}

//!Instruction lduh_imm behavior method.
void ac_behavior( lduh_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("lduh [%s + 0x%x], %s\n", reg_alias[rs1], simm13, reg_alias[rd]);
  #endif

  #ifdef WITH_SRMMU
  MEM.write(0x90000000, (PSR.read() & 0x80) ? 0xB : 0xA);
  #endif
  
  uint32_t addr = readReg(rs1) + simm13;
  uint32_t data = 0;

  if (addr & 0x1)
  {
     trap_selector.set_mem_address_not_aligned(true);
  } else { 
     data = MEM.read_half(addr);
	  if(!trap_selector.is_trap_mode())
	  {
		  writeReg(rd, data);
		  ac_pc = npc;
		  npc = npc + 4;
	  }
  }
}

//!Instruction ld_imm behavior method.
void ac_behavior( ld_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("ld [%s + 0x%x], %s\n", reg_alias[rs1], simm13, reg_alias[rd]);
  #endif

  #ifdef WITH_SRMMU
  MEM.write(0x90000000, (PSR.read() & 0x80) ? 0xB : 0xA);
  #endif

  uint32_t addr = readReg(rs1) + simm13;
  uint32_t data = 0;

  if (addr & 0x3)
  {
     trap_selector.set_mem_address_not_aligned(true);
  } else { 
     data = MEM.read(addr);
	  if(!trap_selector.is_trap_mode())
	  {
		  writeReg(rd, data);
		  ac_pc = npc;
		  npc = npc + 4;
	  }
  }
}

//!Instruction ldd_imm behavior method.
void ac_behavior( ldd_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("ldd [%s + 0x%x], %s\n", reg_alias[rs1], simm13, reg_alias[rd]);
  #endif

  #ifdef WITH_SRMMU
  MEM.write(0x90000000, (PSR.read() & 0x80) ? 0xB : 0xA);
  #endif

  uint32_t addr = readReg(rs1) + simm13;
  uint32_t data_0 = 0;
  uint32_t data_1 = 0;
  
  if (rd & 0x1)
  {
     trap_selector.set_illegal_instruction(true); 
  } else if (addr & 0x7) {
     trap_selector.set_mem_address_not_aligned(true);
  } else {
     data_0 = MEM.read(addr);
     if (!trap_selector.is_trap_mode())
     {
        data_1 = MEM.read(addr + 4);
        if (!trap_selector.is_trap_mode())
        {
				writeReg(rd, data_0);
            writeReg(rd + 1, data_1);
            ac_pc = npc;
            npc   = npc + 4;
        }
     }
  }
}

//!Instruction and_imm behavior method.
void ac_behavior( and_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("and %s, 0x%x, %s\n", reg_alias[rs1], simm13, reg_alias[rd]);
  #endif
  writeReg(rd, readReg(rs1) & simm13);

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction andcc_imm behavior method.
void ac_behavior( andcc_imm )
{
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("andcc %s, 0x%x, %s\n", reg_alias[rs1], simm13, reg_alias[rd]);
  #endif
  uint32_t dest = readReg(rs1) & simm13;

  //!Update PSR integer condition codes
  SET_PSRicc_N(dest >> 31);
  SET_PSRicc_Z(dest == 0);
  SET_PSRicc_V(0);
  SET_PSRicc_C(0);
  
  writeReg(rd, dest);

  ac_pc = npc;
  npc = npc + 4;
};


//!Instruction andn_imm behavior method.
void ac_behavior( andn_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("andn %s, 0x%x, %s\n", reg_alias[rs1], simm13, reg_alias[rd]);
  #endif
  writeReg(rd, readReg(rs1) & ~simm13);

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction andncc_imm behavior method.
void ac_behavior( andncc_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("andncc %s, 0x%x, %s\n", reg_alias[rs1], simm13, reg_alias[rd]);
  #endif
  uint32_t dest = readReg(rs1) & ~simm13;

  //!Update PSR integer condition codes
  SET_PSRicc_N(dest >> 31);
  SET_PSRicc_Z(dest == 0);
  SET_PSRicc_V(0);
  SET_PSRicc_C(0);
  
  writeReg(rd, dest);

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction or_imm behavior method.
void ac_behavior( or_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("or %s, 0x%x, %s\n", reg_alias[rs1], simm13, reg_alias[rd]);
  #endif
  writeReg(rd, readReg(rs1) | simm13);

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction orcc_imm behavior method.
void ac_behavior( orcc_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("orcc %s, 0x%x, %s\n", reg_alias[rs1], simm13, reg_alias[rd]);
  #endif
  uint32_t dest = readReg(rs1) | simm13;

  //!Update PSR integer condition codes
  SET_PSRicc_N(dest >> 31);
  SET_PSRicc_Z(dest == 0);
  SET_PSRicc_V(0);
  SET_PSRicc_C(0);
  
  writeReg(rd, dest);

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction orn_imm behavior method.
void ac_behavior( orn_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("orn %s, 0x%x, %s\n", reg_alias[rs1], simm13, reg_alias[rd]);
  #endif

  writeReg(rd, readReg(rs1) | ~simm13);

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction orncc_imm behavior method.
void ac_behavior( orncc_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("orncc %s, 0x%x, %s\n", reg_alias[rs1], simm13, reg_alias[rd]);
  #endif
  uint32_t dest = readReg(rs1) | ~simm13;

  //!Update PSR integer condition codes
  SET_PSRicc_N(dest >> 31);
  SET_PSRicc_Z(dest == 0);
  SET_PSRicc_V(0);
  SET_PSRicc_C(0);
  
  writeReg(rd, dest);

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction xor_imm behavior method.
void ac_behavior( xor_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("xor %s, 0x%x, %s\n", reg_alias[rs1], simm13, reg_alias[rd]);
  #endif
  writeReg(rd, readReg(rs1) ^ simm13);

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction xorcc_imm behavior method.
void ac_behavior( xorcc_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("xorcc %s, 0x%x, %s\n", reg_alias[rs1], simm13, reg_alias[rd]);
  #endif
  int dest = readReg(rs1) ^ simm13;

  //!Update PSR integer condition codes
  SET_PSRicc_N(dest >> 31);
  SET_PSRicc_Z(dest == 0);
  SET_PSRicc_V(0);
  SET_PSRicc_C(0);
  
  writeReg(rd, dest);

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction xnor_imm behavior method.
void ac_behavior( xnor_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("xnor %s, 0x%x, %s\n", reg_alias[rs1], simm13, reg_alias[rd]);
  #endif
  writeReg(rd, ~(readReg(rs1) ^ simm13));

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction flush_imm behavior method.
void ac_behavior( flush_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("flush [%s + 0x%x] %x\n",reg_alias[rs1], simm13, ac_pc.read());
  #endif
  /*
    If the FLUSH instruction is unimplemented, one of either illegal_instruction trap
    or unimplemented_FLUSH trap (at the implementerâ€™s discretion) will result.
    NOTE: On LEON3 the instruction behave like a NOP. If we try to throw a trap we get a 
    unimplemented intruction for some reason and the simulation stop.
  */
  #ifdef FLUSH_NOP
  ac_pc = npc;
  npc = npc + 4;
  #elif FLUSH_TRAP
  trap_selector.set_unimplemented_FLUSH( true );
  #elif FLUSH_ILLEGAL
  trap_selector.set_illegal_instruction( true );
  #endif  
}

//!Instruction xnorcc_imm behavior method.
void ac_behavior( xnorcc_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("xnorcc %s, 0x%x, %s\n", reg_alias[rs1], simm13, reg_alias[rd]);
  #endif
  int dest = ~(readReg(rs1) ^ simm13);

  //!Update PSR integer condition codes
  SET_PSRicc_N(dest >> 31);
  SET_PSRicc_Z(dest == 0);
  SET_PSRicc_V(0);
  SET_PSRicc_C(0);
  
  writeReg(rd, dest);

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction umul_imm behavior method.
void ac_behavior( umul_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("umul %s, 0x%x, %s\n", reg_alias[rs1], simm13, reg_alias[rd]);
  #endif

  uint64_t tmp = (uint64_t) readReg(rs1) * (uint64_t) simm13;
  writeReg(rd, (uint32_t) tmp);
  Y.write((uint32_t) (tmp >> 32));

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction smul_imm behavior method.
void ac_behavior( smul_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("smul %s, 0x%x, %s\n", reg_alias[rs1], simm13, reg_alias[rd]);
  #endif
  int64_t tmp = (int64_t) readReg(rs1) * (int64_t) simm13;
  writeReg(rd, (int32_t) tmp);
  Y.write((int32_t) (tmp >> 32));

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction umulcc_imm behavior method.
void ac_behavior( umulcc_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("umulcc %s, 0x%x, %s\n", reg_alias[rs1], simm13, reg_alias[rd]);
  #endif
  uint64_t tmp = (uint64_t) readReg(rs1) * (uint64_t) simm13;

  //!Update PSR integer condition codes
  SET_PSRicc_N((uint32_t) tmp >> 31);
  SET_PSRicc_Z((uint32_t) tmp == 0);
  SET_PSRicc_V(0);
  SET_PSRicc_C(0);
  
  writeReg(rd, (uint32_t) tmp);
  Y.write((uint32_t) (tmp >> 32));

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction smulcc_imm behavior method.
void ac_behavior( smulcc_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("smulcc %s, 0x%x, %s\n", reg_alias[rs1], simm13, reg_alias[rd]);
  #endif
  int64_t tmp = (int64_t) readReg(rs1) * (int64_t) simm13;

  //!Update PSR integer condition codes
  SET_PSRicc_N((uint32_t) tmp >> 31);
  SET_PSRicc_Z((uint32_t) tmp == 0);
  SET_PSRicc_V(0);
  SET_PSRicc_C(0);
  
  writeReg(rd, (int32_t) tmp);
  Y.write((int32_t) (tmp >> 32));

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction mulscc_imm behavior method.
void ac_behavior( mulscc_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("mulscc %s, %d, %s\n", reg_alias[rs1], simm13, reg_alias[rd]);
  #endif

  int32_t rs1_0 = readReg(rs1) & 1;

  int32_t op1 = ((PSRicc_N ^ PSRicc_V) << 31) | (readReg(rs1) >> 1);
  int32_t op2 = ((Y.read() & 1) == 0) ? 0 : simm13;
 
  int32_t result = op1 + op2;

  //!Update PSR integer condition codes
  SET_PSRicc_N(result >> 31);
  SET_PSRicc_Z(result == 0);
  SET_PSRicc_V((bit((( op1 &  op2 & ~result) |
	            (~op1 & ~op2 &  result)), 31)));
  SET_PSRicc_C((bit(((op1 &  op2) |
	            (~result & (op1 | op2))), 31)));

  writeReg(rd, result);
  Y.write((rs1_0 << 31) | (Y.read() >> 1));
  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction udiv_imm behavior method.
void ac_behavior( udiv_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("udiv %s, 0x%x, %s\n", reg_alias[rs1], simm13, reg_alias[rd]);
  #endif
  uint64_t tmp;
    
  tmp =  (uint64_t) Y.read() << 32;
  tmp |= (uint32_t) readReg(rs1);
  
  //!division by zero
  if(simm13 == 0)
  {
    trap_selector.set_division_by_zero(true);
  }else{
    tmp /= (uint32_t) simm13;
    uint32_t result;

    //!result overflowed 32 bits; return largest appropriate integer 
    result = (uint32_t) ((tmp >> 32) == 0) ? tmp & 0xFFFFFFFF : 0xFFFFFFFF;
    writeReg(rd, result);

    ac_pc = npc;
    npc = npc + 4;
  }
}

//!Instruction udivcc_imm behavior method.
void ac_behavior( udivcc_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("udivcc %s, 0x%x, %s\n", reg_alias[rs1], simm13, reg_alias[rd]);
  #endif
  uint64_t tmp;
    
  tmp =  (uint64_t) Y.read() << 32;
  tmp |= (uint32_t) readReg(rs1);
  
  //!division by zero
  if(simm13 == 0)
  {
    trap_selector.set_division_by_zero(true);
  }else{
    tmp /= (uint32_t) simm13;
    uint32_t result;

    //!result overflowed 32 bits; return largest appropriate integer 
    result = (uint32_t) ((tmp >> 32) == 0) ? tmp & 0xFFFFFFFF : 0xFFFFFFFF;

    //!Update PSR integer condition codes
    SET_PSRicc_N(result >> 31);
    SET_PSRicc_Z(result == 0);
    SET_PSRicc_V(((tmp >> 32) == 0));
    SET_PSRicc_C(0);

    writeReg(rd, result);

    ac_pc = npc;
    npc = npc + 4;
  }
}

//!Instruction sdiv_imm behavior method.
void ac_behavior( sdiv_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("sdiv %s, 0x%x, %s\n", reg_alias[rs1], simm13, reg_alias[rd]);
  #endif
  int64_t tmp;
    
  tmp = (int64_t) Y.read() << 32;
  tmp |= (int32_t) readReg(rs1);
  
  //!division by zero
  if(simm13 == 0)
  {
    trap_selector.set_division_by_zero(true);
  }else{
    tmp /= (int32_t) simm13;
    int32_t result = (int32_t) (tmp & 0xFFFFFFFF);
    //!result overflowed 32 bits; return largest appropriate integer 
    bool temp_V = (((tmp >> 31) == 0) |
		 ((tmp >> 31) == -1LL)) ? 0 : 1;
    if (temp_V) {
       if(tmp > 0)
          result = 0x7FFFFFFF; //!2^31 - 1
      else 
          result = 0x80000000; //!-2^31
    }

    writeReg(rd, result);

    ac_pc = npc;
    npc = npc + 4;
  }
}

//!Instruction sdivcc_imm behavior method.
void ac_behavior( sdivcc_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("sdivcc %s, 0x%x, %s\n", reg_alias[rs1], simm13, reg_alias[rd]);
  #endif
  int64_t tmp;
    
  tmp = (int64_t) Y.read() << 32;
  tmp |= (int32_t) readReg(rs1);
  
  //!division by zero
  if(simm13 == 0)
  {
    trap_selector.set_division_by_zero(true);
  }else{
    tmp /= (int32_t) simm13;
    int32_t result = (int32_t) (tmp & 0xFFFFFFFF);
    //!result overflowed 32 bits; return largest appropriate integer 
    bool temp_V = (((tmp >> 31) == 0) |
		 ((tmp >> 31) == -1LL)) ? 0 : 1;
    if (temp_V) {
       if(tmp > 0)
          result = 0x7FFFFFFF; //!2^31 - 1
      else 
          result = 0x80000000; //!-2^31
    }

    //!Update PSR integer condition codes
    SET_PSRicc_N(result >> 31);
    SET_PSRicc_Z(result == 0);
    SET_PSRicc_V(temp_V);
    SET_PSRicc_C(0);

    writeReg(rd, result);

    ac_pc = npc;
    npc = npc + 4;
  }
}

//!Instruction rdtbr behavior method.
void ac_behavior( rdtbr ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("rd %%tbr, %s\n",reg_alias[rd]);
  #endif

  if(!PSR_S){
     trap_selector.set_privileged_instruction(true);
  } else {
     writeReg(rd, TBR.read());
     ac_pc = npc;
     npc = npc + 4;
  }
}

//!Instruction wrtbr_imm behavior method.
void ac_behavior( wrtbr_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("wr %s, 0x%x, %%tbr\n", reg_alias[rs1], simm13);
  #endif

  if(!PSR_S){
     trap_selector.set_privileged_instruction(true);
  } else {
     TBR.write(readReg(rs1) ^ simm13);
     ac_pc = npc;
     npc = npc + 4;
  }
}

//!Instruction rdpsr behavior method.
void ac_behavior( rdpsr ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("rd %%psr, %s\n", reg_alias[rd]);
  #endif

  if(!PSR_S){
     trap_selector.set_privileged_instruction(true);
  } else {
     writeReg(rd, PSR.read());
     ac_pc = npc;
     npc = npc + 4;
 }
}

//!Instruction wrpsr_imm behavior method.
void ac_behavior( wrpsr_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("wr %s, 0x%x, %%psr\n", reg_alias[rs1], simm13);
  #endif

  if(!PSR_S){
     trap_selector.set_privileged_instruction(true);
  } else {
     uint32_t value = readReg(rs1) ^ ((uint32_t) simm13);
     //!Check of new CWP is > the number of windows
     if((value & 0x1f) >= NWINDOWS){ 
        trap_selector.set_illegal_instruction(true);
     } else {
       //!Clear impl and ver bits (hardwired)
       PSR.write((clear_bits(value, 31, 24)));
       ac_pc = npc;
       npc = npc + 4;
     }
  }
}

//!Instruction rdwim behavior method.
void ac_behavior( rdwim ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("rd %%wim, %s\n", reg_alias[rd]);
  #endif

  if(!PSR_S){
     trap_selector.set_privileged_instruction(true); 
  } else { 
     writeReg(rd, WIM.read());
     ac_pc = npc;
     npc = npc + 4;
  }
}

//!Instruction wrwim_imm behavior method.
void ac_behavior( wrwim_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("wr %s, 0x%x, %%wim\n", reg_alias[rs1], simm13);
  #endif
  if(PSR_S)
  {
     uint32_t value = readReg(rs1) ^ simm13;
     //!don't write bits corresponding to non-existent windows
     WIM.write(value << (31 - NWINDOWS-1) >> (31 - NWINDOWS - 1));
     ac_pc = npc;
     npc = npc + 4;
  } else { 
     trap_selector.set_privileged_instruction(true); 
  }
}

//!Instruction rett_imm behavior method.
void ac_behavior( rett_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("rett [%s + 0x%x]\n", reg_alias[rs1], simm13);
  #endif

  uint32_t new_CWP = (uint32_t)((PSR.read() & 0x1f) + 1) % NWINDOWS;
  uint32_t address = readReg(rs1) + simm13;

  if (PSR_ET){
     if(!PSR_S){
        trap_selector.set_privileged_instruction(true);
     }else{
        trap_selector.set_illegal_instruction(true);
     }
  }else if(!PSR_S){
     trap_selector.set_privileged_instruction(true);
     error_mode = true;
  }else if(WIM & (1 << new_CWP)){
     trap_selector.set_window_underflow(true);
     error_mode = true;
  }else if((address & 0x3) != 0){
     trap_selector.set_mem_address_not_aligned(true);
     error_mode = true;
  }else{
     ac_pc = npc;
     npc = address;
     SET_PSR_S(PSR_PS);
     SET_PSR_ET(1);
     SET_PSR_CWP(new_CWP);
  }
}

//!Instruction ldfsr_imm behavior method.
void ac_behavior( ldfsr_imm ){
  /*FPU Disabled for now*/
  trap_selector.set_fp_disabled(true);
}

//!Instruction stb_imm behavior method.
void ac_behavior( stb_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("stb %s, [%s + 0x%x]\n", reg_alias[rd], reg_alias[rs1], simm13);
  #endif

  #ifdef WITH_SRMMU
  MEM.write(0x90000000, (PSR.read() & 0x80) ? 0xB : 0xA);
  #endif
  
  uint32_t addr = readReg(rs1) + simm13;
  MEM.write_byte(addr, readReg(rd) & 0xFF);

  if(!trap_selector.is_trap_mode())
  {
     ac_pc = npc;
     npc = npc + 4;
  }
}

//!Instruction sth_imm behavior method.
void ac_behavior( sth_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("sth %s, [%s + 0x%x]\n", reg_alias[rd], reg_alias[rs1], simm13);
  #endif

  #ifdef WITH_SRMMU
  MEM.write(0x90000000, (PSR.read() & 0x80) ? 0xB : 0xA);
  #endif
  
  uint32_t addr = readReg(rs1) + simm13;

  if(addr & 0x1)
  {
	  trap_selector.set_mem_address_not_aligned(true);
  } else {
     MEM.write_half(addr, readReg(rd) & 0xFFFF);
	  if(!trap_selector.is_trap_mode())
	  {
		  ac_pc = npc;
		  npc = npc + 4;
	  }
  }
}

//!Instruction st_imm behavior method.
void ac_behavior( st_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("st %s, [%s + 0x%x]\n", reg_alias[rd], reg_alias[rs1], simm13);
  #endif

  #ifdef WITH_SRMMU
  MEM.write(0x90000000, (PSR.read() & 0x80) ? 0xB : 0xA);
  #endif

  uint32_t addr = readReg(rs1) + simm13;
  
  if(addr & 0x3)
  {
	  trap_selector.set_mem_address_not_aligned(true);
  } else {  
     MEM.write(addr, readReg(rd) & 0xffffffff);
	  if(!trap_selector.is_trap_mode())
	  {
		  ac_pc = npc;
		  npc = npc + 4;
	  }
  }
}

//!Instruction std_imm behavior method.
void ac_behavior( std_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("std %s, [%s + 0x%x]\n", reg_alias[rd], reg_alias[rs1], simm13);
  #endif

  #ifdef WITH_SRMMU
  MEM.write(0x90000000, (PSR.read() & 0x80) ? 0xB : 0xA);
  #endif

  uint32_t addr = readReg(rs1) + simm13;
  uint32_t data_0 = 0;
  uint32_t data_1 = 0;

  if (rd & 0x1)
  {
     trap_selector.set_illegal_instruction(true); 
  } else if (addr & 0x7) {
     trap_selector.set_mem_address_not_aligned(true);
  } else {
     MEM.write(addr, readReg(rd));
     if(!trap_selector.is_trap_mode())
     {
        MEM.write(addr + 4, readReg(rd + 1));
		  if(!trap_selector.is_trap_mode())
		  {
		    ac_pc = npc;
		    npc = npc + 4;
		  }
     }
  }
}

//!Instruction ldstub_imm behavior method.
void ac_behavior( ldstub_imm ){
  #ifdef PRINT_INSTRUCTION
  dbg_printf("ldstub %s, [%s + 0x%x]\n", reg_alias[rd], reg_alias[rs1], simm13);
  #endif

  //!wait for lock(s) to be lifted
  while ((pb_block_ldst_byte == 1) || (pb_block_ldst_word == 1)) 
  {
   /*
	   an implementation actually need only block when another LDSTUB or SWAP
		is pending on the same byte in memory as the one addressed by this LDSTUB
	*/
  }

  #ifdef WITH_SRMMU
  MEM.write(0x90000000, (PSR.read() & 0x80) ? 0xB : 0xA);
  #endif

  //!Acquire the lock
  pb_block_ldst_byte = 1;

  uint32_t addr = readReg(rs1) + simm13;
  uint32_t data = MEM.read_byte(addr);

  //!Release the lock
  pb_block_ldst_byte = 0;
  
  if(!trap_selector.is_trap_mode())
  { 
     MEM.write_byte(addr, 0xFF);

	  if(!trap_selector.is_trap_mode())
	  {
		  writeReg(rd, data & 0xFF);
		  ac_pc = npc;
		  npc = npc + 4;
	  }
  }
}

//!Instruction swap_imm behavior method.
void ac_behavior( swap_imm ){
  #ifdef PRINT_INSTRUCTION
  dbg_printf("swap %s, [%s + 0x%x]\n", reg_alias[rd], reg_alias[rs1], simm13);
  #endif

  uint32_t temp = readReg(rd);
  //!wait for lock(s) to be lifted
  while ((pb_block_ldst_byte == 1) || (pb_block_ldst_word == 1)) 
  {
   /*
	   an implementation actually need only block when another LDSTUB or SWAP
		is pending on the same byte in memory as the one addressed by this LDSTUB
	*/
  }

  #ifdef WITH_SRMMU
  MEM.write(0x90000000, (PSR.read() & 0x80) ? 0xB : 0xA);
  #endif

  //!Acquire the lock
  pb_block_ldst_word = 1;

  uint32_t addr = readReg(rs1) + simm13;
  uint32_t data = MEM.read(addr);

  //!Release the lock
  pb_block_ldst_word = 0;
  
  if(!trap_selector.is_trap_mode())
  { 
     MEM.write(addr, temp);

	  if(!trap_selector.is_trap_mode())
	  {
		  writeReg(rd, data);
		  ac_pc = npc;
		  npc = npc + 4;
	  }
  }
}

//!Instruction sll_imm behavior method.
void ac_behavior( sll_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("sll %s, 0x%x, %s\n", reg_alias[rs1], simm13, reg_alias[rd]);
  #endif
  writeReg(rd, readReg(rs1) << simm13);
  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction srl_imm behavior method.
void ac_behavior( srl_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("srl %s, 0x%x, %s\n", reg_alias[rs1], simm13, reg_alias[rd]);
  #endif
  writeReg(rd, ((uint32_t) readReg(rs1)) >> ((uint32_t) simm13));
  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction sra_imm behavior method.
void ac_behavior( sra_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("sra %s, 0x%x, %s\n", reg_alias[rs1], simm13, reg_alias[rd]);
  #endif
  writeReg(rd, ((int32_t) readReg(rs1)) >> ((int32_t) simm13));
  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction add_imm behavior method.
void ac_behavior( add_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("add %s, 0x%x, %s\n", reg_alias[rs1], simm13, reg_alias[rd]);
  #endif
  writeReg(rd, readReg(rs1) + simm13);
  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction addcc_imm behavior method.
void ac_behavior( addcc_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("addcc %s, 0x%x, %s\n", reg_alias[rs1], simm13, reg_alias[rd]);
  #endif

  uint32_t dest = readReg(rs1) + simm13;

  //!Update PSR integer condition codes
  SET_PSRicc_N(dest >> 31);
  SET_PSRicc_Z(dest == 0);
  SET_PSRicc_V((bit((readReg(rs1) &  simm13 & ~dest) |
	                 (~readReg(rs1) & ~simm13 &  dest) , 31)));
  SET_PSRicc_C((bit((readReg(rs1) & simm13) |
	                 (~dest & (readReg(rs1) | simm13)), 31)));
  
  writeReg(rd, dest);

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction addx_imm behavior method.
void ac_behavior( addx_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("addx %s, 0x%x, %s\n", reg_alias[rs1], simm13, reg_alias[rd]);
  #endif
  writeReg(rd, readReg(rs1) + simm13 + PSRicc_C);

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction addxcc_imm behavior method.
void ac_behavior( addxcc_imm ){
  #ifdef PRINT_INSTRUCTION
  dbg_printf("addxcc %s, 0x%x, %s\n", reg_alias[rs1], simm13, reg_alias[rd]);
  #endif

  uint32_t dest = readReg(rs1) + simm13 + PSRicc_C;

  //!Update PSR integer condition codes
  SET_PSRicc_N(dest >> 31);
  SET_PSRicc_Z(dest == 0);
  SET_PSRicc_V((bit((readReg(rs1) &  simm13 & ~dest) |
	                 (~readReg(rs1) & ~simm13 &  dest) , 31)));
  SET_PSRicc_C((bit((readReg(rs1) & simm13) |
	                 (~dest & (readReg(rs1) | simm13)), 31)));
  
  writeReg(rd, dest);

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction taddcc_imm behavior method.
void ac_behavior( taddcc_imm ){
  //TODO:
  printf("unimplemented instruction taddcc_imm\n");
  stop(EXIT_FAILURE);
}

//!Instruction taddcctv_imm behavior method.
void ac_behavior( taddcctv_imm ){
  //TODO:
  printf("unimplemented instruction taddcctv_imm\n");
  stop(EXIT_FAILURE);
}

//!Instruction sub_imm behavior method.
void ac_behavior( sub_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("sub %s, 0x%x, %s\n", reg_alias[rs1], simm13, reg_alias[rd]);
  #endif
  writeReg(rd, (readReg(rs1) - simm13));
  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction subcc_imm behavior method.
void ac_behavior( subcc_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("subcc %s, 0x%x, %s\n", reg_alias[rs1], simm13, reg_alias[rd]);
  #endif
  uint32_t dest = readReg(rs1) - simm13;

  //!Update PSR integer condition codes
  SET_PSRicc_N(dest >> 31);
  SET_PSRicc_Z(dest == 0);
  SET_PSRicc_V((bit((readReg(rs1) &  ~simm13 & ~dest) |
	                 (~readReg(rs1) & simm13 &  dest) , 31)));
  SET_PSRicc_C((bit((~readReg(rs1) & simm13) |
	                 (dest & (~readReg(rs1) | simm13)), 31)));
  
  writeReg(rd, dest);

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction subx_imm behavior method.
void ac_behavior( subx_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("subx %s, 0x%x, %s\n", reg_alias[rs1], simm13, reg_alias[rd]);
  #endif
  writeReg(rd, readReg(rs1) - simm13 - PSRicc_C);

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction subxcc_imm behavior method.
void ac_behavior( subxcc_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("subxcc %s, 0x%x, %s\n", reg_alias[rs1], simm13, reg_alias[rd]);
  #endif
  uint32_t dest = readReg(rs1) - simm13 - PSRicc_C;

  //!Update PSR integer condition codes
  SET_PSRicc_N(dest >> 31);
  SET_PSRicc_Z(dest == 0);
  SET_PSRicc_V((bit((readReg(rs1) &  ~simm13 & ~dest) |
	                 (~readReg(rs1) & simm13 &  dest) , 31)));
  SET_PSRicc_C((bit((~readReg(rs1) & simm13) |
	                 (dest & (~readReg(rs1) | simm13)), 31)));
  
  writeReg(rd, dest);

  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction tsubcc_imm behavior method.
void ac_behavior( tsubcc_imm ){
  //TODO:
  printf("unimplemented instruction tsubcc_imm\n");
  stop(EXIT_FAILURE);
}

//!Instruction tsubcctv_imm behavior method.
void ac_behavior( tsubcctv_imm ){
  //TODO:
  printf("unimplemented instruction tsubcctv_imm\n");
  stop(EXIT_FAILURE);
}

//!Instruction jmpl_imm behavior method.
void ac_behavior( jmpl_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("jmpl %s, 0x%x, %s\n", reg_alias[rs1], simm13, reg_alias[rd]);
  #endif

  uint32_t addr = readReg(rs1) + simm13;

  if (addr & 0x3)
  {
    trap_selector.set_mem_address_not_aligned(true);
  }else{ 
    writeReg(rd, ac_pc);

    ac_pc = npc;
    npc = addr;
  }
}

//!Instruction save_imm behavior method.
void ac_behavior( save_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("save %s, 0x%x, %s\n", reg_alias[rs1], simm13, reg_alias[rd]);
  #endif

  int result;
  uint32_t new_CWP = (uint32_t)((PSR_CWP) - 1) % NWINDOWS;

  if (WIM.read() & (1 << new_CWP)){
     trap_selector.set_window_overflow(true);
  }else{
      result = readReg(rs1) + simm13; //!source operands are read from old window
      SET_PSR_CWP(new_CWP);
      writeReg(rd, result);
      ac_pc = npc;
      npc = npc + 4;
  }
}

//!Instruction restore_imm behavior method.
void ac_behavior( restore_imm ){
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("restore %s, 0x%x, %s\n", reg_alias[rs1], simm13, reg_alias[rd]);
  #endif

  int result;
  uint32_t new_CWP = (uint32_t)((PSR_CWP) + 1) % NWINDOWS;


  if (WIM.read()  & (1 << new_CWP)){
     trap_selector.set_window_underflow(true);
  }else{
      result = readReg(rs1) + simm13;
      SET_PSR_CWP(new_CWP);
      writeReg(rd, result);
      ac_pc = npc;
      npc = npc + 4;
  }
}

//!Instruction rdy behavior method.
void ac_behavior( rdy ){
  switch(rs1) {
    case 0 : 
       #ifdef PRINT_INSTRUCTION  
       dbg_printf("rd %%y, %s \n",reg_alias[rd]);
       #endif
       writeReg(rd, Y.read());
    break;
    case 1 ... 31 :
      #ifdef PRINT_INSTRUCTION 
      dbg_printf("rd %%asr%d, %s\n",rs1, reg_alias[rd]);
      #endif
      writeReg(rd, ASR[rs1]);
      if(rd == 19)
        printf("Read ASR19 %d\n", ASR[rs1]);
    break;
    default:
      stop(EXIT_FAILURE);
  }
  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction wry_imm behavior method.
void ac_behavior( wry_imm ){
  switch(rd) {
    case 0 : 
       Y.write(readReg(rs1) ^ simm13);
       #ifdef PRINT_INSTRUCTION  
       dbg_printf("wr %%y, 0x%x\n",readReg(rs1) ^ simm13 );
       #endif
    break;
    case 1 ... 31 :
      #ifdef PRINT_INSTRUCTION 
      dbg_printf("rd %%asr%d, %s\n",rs1, reg_alias[rd]);
      #endif
      ASR[rd] = (readReg(rs1) ^ simm13);
      if(rd == 19)
        printf("power down mode unimplemented %d\n", ASR[19]);
    break;
    default:
      stop(EXIT_FAILURE);
  }
  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction unimplemented behavior method.
void ac_behavior( unimplemented ){
  #ifdef UNIMPLEMENTED_TRAP
  trap_selector.set_illegal_instruction(true);
  #else
  error_mode = 1;
  #endif
}

//!Instruction ta behavior method.
void ac_behavior( ta ){
  int32_t trap_number = readReg(r1) + readReg(rs2);
  uint8_t trap_type = (trap_number & 0x7F);
  #ifdef PRINT_INSTRUCTION
  dbg_printf("ta 0x%x\n",trap_number);
  #endif
  //execute trap
  trap_selector.set_trap_instruction(trap_type);  
}

//!Instruction tn behavior method.
void ac_behavior( tn ){
  #ifdef PRINT_INSTRUCTION
  dbg_printf("tn\n");
  #endif
  //!This instruction acts like a nop
  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction tne behavior method.
void ac_behavior( tne ){
  int32_t trap_number = readReg(r1) + readReg(rs2);
  #ifdef PRINT_INSTRUCTION
  dbg_printf("tne 0x%x\n",trap_number);
  #endif

  if(PSRicc_Z == 0){
     uint8_t trap_type = (trap_number & 0x7F);
     //!execute trap
     trap_selector.set_trap_instruction(trap_type);     
  }else{
      ac_pc = npc;
      npc = npc + 4;//!The instruction acts like a nop
  } 
}

//!Instruction te behavior method.
void ac_behavior( te ){
  uint32_t  trap_number = readReg(r1) + readReg(rs2);
  #ifdef PRINT_INSTRUCTION
  dbg_printf("te 0x%x\n",trap_number);
  #endif

  if(PSRicc_Z == 1){
     uint8_t  trap_type = (trap_number & 0x7F);
     trap_selector.set_trap_instruction(trap_type);
  }else{
     ac_pc = npc;
     npc = npc + 4;//!The instruction acts like a nop
  } 
}

//!Instruction tg behavior method.
void ac_behavior( tg ){
  int32_t trap_number = readReg(r1) + readReg(rs2);
  #ifdef PRINT_INSTRUCTION
  dbg_printf("tg 0x%x\n",trap_number);
  #endif

  if((PSRicc_Z | (PSRicc_N ^ PSRicc_V)) == 0){
     uint8_t trap_type = (trap_number & 0x7F);
     trap_selector.set_trap_instruction(trap_type);
  }else{
     ac_pc = npc;
     npc = npc + 4;//!The instruction acts like a nop
  }
}

//!Instruction tle behavior method.
void ac_behavior( tle ){
  int32_t trap_number = readReg(r1) + readReg(rs2);
  #ifdef PRINT_INSTRUCTION
  dbg_printf("tle 0x%x\n",trap_number);
  #endif

  if((PSRicc_Z | (PSRicc_N ^ PSRicc_V)) == 1){
     uint8_t trap_type = (trap_number & 0x7F);
     trap_selector.set_trap_instruction(trap_type);
  }else{
     ac_pc = npc;
     npc = npc + 4;//!The instruction acts like a nop
  }
}

//!Instruction tge behavior method.
void ac_behavior( tge ){
  int32_t trap_number = readReg(r1) + readReg(rs2);
  #ifdef PRINT_INSTRUCTION
  dbg_printf("tge 0x%x\n",trap_number);
  #endif

  if((PSRicc_N ^ PSRicc_V) == 0){
     uint8_t trap_type = (trap_number & 0x7F);
     trap_selector.set_trap_instruction(trap_type);
  }else{
     ac_pc = npc;
     npc = npc + 4;//!The instruction acts like a nop
  }
}

//!Instruction tl behavior method.
void ac_behavior( tl ){
  int32_t trap_number = readReg(r1) + readReg(rs2);
  #ifdef PRINT_INSTRUCTION
  dbg_printf("tl 0x%x\n",trap_number);
  #endif

  if((PSRicc_N ^ PSRicc_V) == 1){
     uint8_t trap_type = (trap_number & 0x7F);
     trap_selector.set_trap_instruction(trap_type);
  }else{
     ac_pc = npc;
     npc = npc + 4;//!The instruction acts like a nop
  }
}

//!Instruction tgu behavior method.
void ac_behavior( tgu ){
  int32_t trap_number = readReg(r1) + readReg(rs2);
  #ifdef PRINT_INSTRUCTION
  dbg_printf("tgu 0x%x\n",trap_number);
  #endif

  if((PSRicc_C == 0) && (PSRicc_Z == 0)){
     uint8_t trap_type = (trap_number & 0x7F);
     trap_selector.set_trap_instruction(trap_type);
  }else{
     ac_pc = npc;
     npc = npc + 4;//!The instruction acts like a nop
  }
}

//!Instruction tleu behavior method.
void ac_behavior( tleu ){
  int32_t trap_number = readReg(r1) + readReg(rs2);
  #ifdef PRINT_INSTRUCTION
  dbg_printf("tleu 0x%x\n",trap_number);
  #endif

  if((PSRicc_C == 1) || (PSRicc_Z == 1)){
     uint8_t trap_type = (trap_number & 0x7F);
     trap_selector.set_trap_instruction(trap_type);
  }else{
     ac_pc = npc;
     npc = npc + 4;//!The instruction acts like a nop
  }
}

//!Instruction tcc behavior method.
void ac_behavior( tcc ){
  int32_t trap_number = readReg(r1) + readReg(rs2);
  #ifdef PRINT_INSTRUCTION
  dbg_printf("tcc 0x%x\n",trap_number);
  #endif

  if(PSRicc_C == 0){
     uint8_t trap_type = (trap_number & 0x7F);
     trap_selector.set_trap_instruction(trap_type);
  }else{
     ac_pc = npc;
     npc = npc + 4;//!The instruction acts like a nop
  }
}

//!Instruction tcs behavior method.
void ac_behavior( tcs ){
  int32_t trap_number = readReg(r1) + readReg(rs2);
  #ifdef PRINT_INSTRUCTION
  dbg_printf("tcs 0x%x\n",trap_number);
  #endif

  if(PSRicc_C == 1){
     uint8_t trap_type = (trap_number & 0x7F);
     trap_selector.set_trap_instruction(trap_type);
  }else{
     ac_pc = npc;
     npc = npc + 4;//!The instruction acts like a nop
  }
}

//!Instruction tpos behavior method.
void ac_behavior( tpos ){
  int32_t trap_number = readReg(r1) + readReg(rs2);
  #ifdef PRINT_INSTRUCTION
  dbg_printf("tpos 0x%x\n",trap_number);
  #endif

  if(PSRicc_N == 0){
     uint8_t trap_type = (trap_number & 0x7F);
     trap_selector.set_trap_instruction(trap_type);
  }else{
     ac_pc = npc;
     npc = npc + 4;//!The instruction acts like a nop
  }
}

//!Instruction tneg behavior method.
void ac_behavior( tneg ){
  int32_t trap_number = readReg(r1) + readReg(rs2);
  #ifdef PRINT_INSTRUCTION
  dbg_printf("tneg 0x%x\n",trap_number);
  #endif

  if(PSRicc_N == 1){
     uint8_t trap_type = (trap_number & 0x7F);
     trap_selector.set_trap_instruction(trap_type);
  }else{
     ac_pc = npc;
     npc = npc + 4;//!The instruction acts like a nop
  }
}

//!Instruction tvc behavior method.
void ac_behavior( tvc ){
  int32_t trap_number = readReg(r1) + readReg(rs2);
  #ifdef PRINT_INSTRUCTION
  dbg_printf("tvc 0x%x\n",trap_number);
  #endif

  if(PSRicc_V == 0){
     uint8_t trap_type = (trap_number & 0x7F);
     trap_selector.set_trap_instruction(trap_type);
  }else{
     ac_pc = npc;
     npc = npc + 4;//!The instruction acts like a nop
  }
}

//!Instruction tvs behavior method.
void ac_behavior( tvs ){
  int32_t trap_number = readReg(r1) + readReg(rs2);
  #ifdef PRINT_INSTRUCTION
  dbg_printf("tvs 0x%x\n",trap_number);
  #endif

  if(PSRicc_V == 1){
     uint8_t trap_type = (trap_number & 0x7F);
     trap_selector.set_trap_instruction(trap_type);
  }else{
     ac_pc = npc;
     npc = npc + 4;//!The instruction acts like a nop
  }
}

//!Instruction ta_imm behavior method.
void ac_behavior( ta_imm ){
  int32_t trap_number = readReg(r1) + sign_ext7(imm7);
  uint8_t trap_type = (trap_number & 0x7F);

  #ifdef PRINT_INSTRUCTION 
  dbg_printf("ta 0x%x\n",trap_number);
  #endif

  trap_selector.set_trap_instruction(trap_type);  
}

//!Instruction tn_imm behavior method.
void ac_behavior( tn_imm ){
  #ifdef PRINT_INSTRUCTION
  dbg_printf("tn\n");
  #endif
  //!This instruction acts like a nop
  ac_pc = npc;
  npc = npc + 4;
}

//!Instruction tne_imm behavior method.
void ac_behavior( tne_imm ){
  int32_t trap_number = readReg(r1) + sign_ext7(imm7);
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("tne 0x%x\n",trap_number);
  #endif
  if(PSRicc_Z == 0){
     uint8_t trap_type = (trap_number & 0x7F);
     trap_selector.set_trap_instruction(trap_type);     
  }else{
     ac_pc = npc;
     npc = npc + 4;//!The instruction acts like a nop
  } 
}

//!Instruction te_imm behavior method.
void ac_behavior( te_imm ){
  uint32_t  trap_number = readReg(r1) + sign_ext7(imm7);
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("te 0x%x\n",trap_number);
  #endif
  if(PSRicc_Z == 1){
     uint8_t  trap_type = (trap_number & 0x7F);
     trap_selector.set_trap_instruction(trap_type);
  }else{
     ac_pc = npc;
     npc = npc + 4;//!The instruction acts like a nop
  } 
}

//!Instruction tg_imm behavior method.
void ac_behavior( tg_imm ){
  int32_t trap_number = readReg(r1) + sign_ext7(imm7);
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("tg 0x%x\n",trap_number);
  #endif

  if((PSRicc_Z | (PSRicc_N ^ PSRicc_V)) == 0){
     uint8_t trap_type = (trap_number & 0x7F);
     trap_selector.set_trap_instruction(trap_type);
  }else{
     ac_pc = npc;
     npc = npc + 4;//!The instruction acts like a nop
  }
}

//!Instruction tle_imm behavior method.
void ac_behavior( tle_imm ){
  int32_t trap_number = readReg(r1) + sign_ext7(imm7);
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("tle 0x%x\n",trap_number);
  #endif

  if((PSRicc_Z | (PSRicc_N ^ PSRicc_V)) == 1){
     uint8_t trap_type = (trap_number & 0x7F);
     trap_selector.set_trap_instruction(trap_type);
  }else{
     ac_pc = npc;
     npc = npc + 4;//!The instruction acts like a nop
  }
}

//!Instruction tge_imm behavior method.
void ac_behavior( tge_imm ){
  int32_t trap_number = readReg(r1) + sign_ext7(imm7);
  #ifdef PRINT_INSTRUCTION
  dbg_printf("tge 0x%x\n",trap_number);
  #endif
  if((PSRicc_N ^ PSRicc_V) == 0){
     uint8_t trap_type = (trap_number & 0x7F);
     trap_selector.set_trap_instruction(trap_type);
  }else{
     ac_pc = npc;
     npc = npc + 4;//!The instruction acts like a nop
  }
}

//!Instruction tl_imm behavior method.
void ac_behavior( tl_imm ){
  int32_t trap_number = readReg(r1) + sign_ext7(imm7);
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("tl 0x%x\n",trap_number);
  #endif

  if((PSRicc_N ^ PSRicc_V) == 1){
     uint8_t trap_type = (trap_number & 0x7F);
     trap_selector.set_trap_instruction(trap_type);
  }else{
     ac_pc = npc;
     npc = npc + 4;//!The instruction acts like a nop
  }
}

//!Instruction tgu_imm behavior method.
void ac_behavior( tgu_imm ){
  int32_t trap_number = readReg(r1) + sign_ext7(imm7);
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("tgu 0x%x\n",trap_number);
  #endif

  if((PSRicc_C == 0) && (PSRicc_Z == 0)){
     uint8_t trap_type = (trap_number & 0x7F);
     trap_selector.set_trap_instruction(trap_type);
  }else{
     ac_pc = npc;
     npc = npc + 4;//!The instruction acts like a nop
  }
}

//!Instruction tleu_imm behavior method.
void ac_behavior( tleu_imm ){
  int32_t trap_number = readReg(r1) + sign_ext7(imm7);
  #ifdef PRINT_INSTRUCTION
  dbg_printf("tleu 0x%x\n",trap_number);
  #endif
  if((PSRicc_C == 1) || (PSRicc_Z == 1)){
     uint8_t trap_type = (trap_number & 0x7F);
     trap_selector.set_trap_instruction(trap_type);
  }else{
     ac_pc = npc;
     npc = npc + 4;//!The instruction acts like a nop
  }
}

//!Instruction tcc_imm behavior method.
void ac_behavior( tcc_imm ){
  int32_t trap_number = readReg(r1) + sign_ext7(imm7);
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("tcc 0x%x\n",trap_number);
  #endif

  if(PSRicc_C == 0){
     uint8_t trap_type = (trap_number & 0x7F);
     trap_selector.set_trap_instruction(trap_type);
  }else{
     ac_pc = npc;
     npc = npc + 4;//!The instruction acts like a nop
  }
}

//!Instruction tcs_imm behavior method.
void ac_behavior( tcs_imm ){
  int32_t trap_number = readReg(r1) + sign_ext7(imm7);
  #ifdef PRINT_INSTRUCTION 
  dbg_printf("tcs 0x%x\n",trap_number);
  #endif

  if(PSRicc_C == 1){
     uint8_t trap_type = (trap_number & 0x7F);
     trap_selector.set_trap_instruction(trap_type);
  }else{
     ac_pc = npc;
     npc = npc + 4;//!The instruction acts like a nop
  }
}

//!Instruction tpos_imm behavior method.
void ac_behavior( tpos_imm ){
  int32_t trap_number = readReg(r1) + sign_ext7(imm7);
  #ifdef PRINT_INSTRUCTION
  dbg_printf("tpos 0x%x\n",trap_number);
  #endif

  if(PSRicc_N == 0){
     uint8_t trap_type = (trap_number & 0x7F);
     trap_selector.set_trap_instruction(trap_type);
  }else{
     ac_pc = npc;
     npc = npc + 4;//!The instruction acts like a nop
  }
}

//!Instruction tneg_imm behavior method.
void ac_behavior( tneg_imm ){
  int32_t trap_number = readReg(r1) + sign_ext7(imm7);
  #ifdef PRINT_INSTRUCTION
  dbg_printf("tneg 0x%x\n",trap_number);
  #endif

  if(PSRicc_N == 1){
     uint8_t trap_type = (trap_number & 0x7F);
     trap_selector.set_trap_instruction(trap_type);
  }else{
     ac_pc = npc;
     npc = npc + 4;//!The instruction acts like a nop
  }
}

//!Instruction tvc_imm behavior method.
void ac_behavior( tvc_imm ){
  int32_t trap_number = readReg(r1) + sign_ext7(imm7);
  #ifdef PRINT_INSTRUCTION
  dbg_printf("tvc 0x%x\n",trap_number);
  #endif

  if(PSRicc_V == 0){
     uint8_t trap_type = (trap_number & 0x7F);
     trap_selector.set_trap_instruction(trap_type);
  }else{
     ac_pc = npc;
     npc = npc + 4;//!The instruction acts like a nop
  }
}

//!Instruction tvs_imm behavior method.
void ac_behavior( tvs_imm ){
  int32_t trap_number = readReg(r1) + sign_ext7(imm7);

  #ifdef PRINT_INSTRUCTION
  dbg_printf("tvs 0x%x\n",trap_number);
  #endif

  if(PSRicc_V == 1){
     uint8_t trap_type = (trap_number & 0x7F);
     trap_selector.set_trap_instruction(trap_type);
  }else{
     ac_pc = npc;
     npc = npc + 4;//!The instruction acts like a nop
  }
}

