/**
 * \file leon3_intr_handlers.cpp
 * 
 * \author Rogerio Alves Cardoso
 * 
 * \brief  LEON-3/SPARC V8 trap/interruption handler
 * 
 * Behavior implementation file template.             
 * This file is automatically generated by ArchC      
 * WITHOUT WARRANTY OF ANY KIND, either express       
 * or implied.                                        
 * For more information on ArchC, please visit:       
 * http://www.archc.org                               
 *                                                    
 * The ArchC Team                                     
 * Computer Systems Laboratory (LSC)                  
 * IC-UNICAMP                                         
 * http://www.lsc.ic.unicamp.br   
 * 
 * \attention 
 * Copyright (C) 2002-2015 --- The ArchC Team
 *
 * This library is free software; you can redistribute    
 * it and/or modify it under the terms of the GNU         
 * Lesser General Public                                  
 * License as published by the Free Software Foundation; 
 * either version 2.1 of the License, or (at your option) 
 * any later version.                                     
 *                              
 * This library is distributed in the hope that it        
 * will be useful, but WITHOUT ANY WARRANTY;        
 * without even the implied warranty of       
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   
 * See the GNU Lesser General Public License for      
 * more details.
 *                      
 ******************************************************/


#include <iostream>

#include "ac_intr_handler.H"
#include "leon3_intr_handlers.H"

#include "leon3_ih_bhv_macros.H"
#include "leon3_cpu_helper.H"

//!'using namespace' statement to allow access to all leon3-specific datatypes
using namespace leon3_parms;

void ac_behavior(intp, value) 
{
  if(value == 0x60)
  {
    trap_selector.set_instruction_access_exception(true);
  }else if (value == 0x7f){
     trap_selector.set_data_access_exception(true);
  }else{
    if( PSR_ET && ((value == 15) || (value > PSR_PIL)) )
    {
         //!Clear acknowledge interruption
         //!FIXME: Create a SystemC ack signal instead 
         MEM.write(0x90000000,0x1C);
         MEM.write(0x8000020C,value);

         trap_selector.set_interrupt_level(value);
    }
  }
};

//!Trap handler select the highest priority trap and then causes a trap
//!Check the SPARCv8 Architectural Manual to more info
void execute_trap()
{
  uint32_t new_CWP;
  unsigned char tt = trap_selector.get_tt();
  trap_selector.clean();

  if(PSR_ET){
      SET_PSR_ET(0);
      SET_PSR_PS((PSR_S));
      new_CWP = (uint32_t)((PSR_CWP) - 1) % NWINDOWS;
      //!NOTE: No overflow/underflow test here
      SET_PSR_CWP(new_CWP);
      writeReg(17, ac_pc.read());
      writeReg(18, npc);

      //Entering in Supervisor Mode
      SET_PSR_S(1);
      MEM.write(0x90000000, 0x9);

      if (tt > 0) {
        int value = TBR.read();
        value = value & 0xfffff000;
        value = value | (tt << 4);
        TBR.write(value);

        ac_pc = TBR.read();
        npc = ac_pc + 4;
                 
      } else if (tt == 0) {
        ac_pc = 0;
        npc = 4;
      }
  } else {
     //!Reset trap may occour even with trap disabled
     if( tt == 0 )
     {
        ac_pc = 0;
        npc = 4;
     } else {
       printf("ERROR: Trap 0x%x with PSR.ET = 0 at PC=0x%x\n",tt, (uint32_t) ac_pc.read()); 
       stop(EXIT_FAILURE);
     }
  }
};